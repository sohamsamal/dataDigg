{"Questions": [{"points": "1", "Answer": "3", "correct_ans_explanation": "Java has its own order of operations. In this case, multiplication, division, and modular arithmetic all have equal priority within Java. So, you would start with the leftmost function and then keep going to the right. So, 3 * 6 = 18, 18 / 4 = 4 (round down because  it is an integer), and 4 % 3 = 1. Then, since subtraction has a lower priority than the other stated functions, this operation is done last. 13 - 1 = 12, so 12 is the correct answer.\n", "wrong_ans_explanation": "Java has its own order of operations. In this case, multiplication, division, and modular arithmetic all have equal priority within Java. So, you would start with the leftmost function and then keep going to the right. So, 3 * 6 = 18, 18 / 4 = 4 (round down because  it is an integer), and 4 % 3 = 1. Then, since subtraction has a lower priority than the other stated functions, this operation is done last. 13 - 1 = 12, so 12 is the correct answer.\n", "question": "What value is stored in end if\n    \n    int end = 13 - 3 * 6 / 4 % 3;\n        \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0\n\n", "\n 13\n\n", "\n -1\n\n", "\n 12 \n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "This problem relies on nested if-else statements. Firstly, x >= 0 so we go inside the first if-statement. x <= 100 so we go into the second if statement. Then y is set to 90 (30 * 3 = 90), but y is not less than 50, so we skip the next if statement. Since the rest of the else statements are paired up with the first two if statements (if you are unsure about the pairing of if and else statements, look at the indenting), we can skip these else statements. Therefore, we end up with x = 30 and y = 90.\n", "wrong_ans_explanation": "This problem relies on nested if-else statements. Firstly, x >= 0 so we go inside the first if-statement. x <= 100 so we go into the second if statement. Then y is set to 90 (30 * 3 = 90), but y is not less than 50, so we skip the next if statement. Since the rest of the else statements are paired up with the first two if statements (if you are unsure about the pairing of if and else statements, look at the indenting), we can skip these else statements. Therefore, we end up with x = 30 and y = 90.\n", "question": "What values are stored in x and y after execution of the following program segment?\n        \n    int x = 30;\n    int y = 30;\n    if (x >= 0)\n    {\n        if (x <= 100)\n        {\n            y = x * 3;\n            if (y < 50)\n                x /= 10;\n        }\n        else\n            y = x * 2;\n    }\n    else\n        y = -x;\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n x = 30 and y = 90  \n\n", "\n x = 30 and y = -30 \n\n", "\n x = 30 and y = 60 \n\n", "\n x = 30 and y = 40 \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Remember: FINAL denotes that the values are constant and cannot be changed. In this problem, when a1 is set to b1, it tries to change the values within a1, which causes a compile-time error. Therefore, nothing will be printed due to a compile-time error.  \n", "wrong_ans_explanation": "Remember: FINAL denotes that the values are constant and cannot be changed. In this problem, when a1 is set to b1, it tries to change the values within a1, which causes a compile-time error. Therefore, nothing will be printed due to a compile-time error.  \n", "question": "Consider the following code segment:\n               \n    final int[] a1 = {1, 2};\n    int[] b1 = {3, 4};\n    a1 = b1;\n    System.out.print(a1[1]);\n        \nWhat is printed as a result of executing the code segment?\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 2 \n\n", "\n 3 \n\n", "\n Nothing will be printed due to compile-time error \n\n", "\n Nothing will be printed due to run-time error \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "There are two different ways to use the substring method. Firstly, you can use two parameters with the first one being the index you want to start the substring and the last parameter being one plus the index you want to stop the substring. \nSecondly, you can use one parameter that denotes the index you want to start the substring and Java will assume that you want the substring to include the rest of the string. To get \u201cscience\u201d out of \u201ccomputer science,\u201d you can either include one parameter (s.substring(9)) or make the second parameter the last index + 1, which is 16. Therefore, I and III are the correct options. \n", "wrong_ans_explanation": "There are two different ways to use the substring method. Firstly, you can use two parameters with the first one being the index you want to start the substring and the last parameter being one plus the index you want to stop the substring. \nSecondly, you can use one parameter that denotes the index you want to start the substring and Java will assume that you want the substring to include the rest of the string. To get \u201cscience\u201d out of \u201ccomputer science,\u201d you can either include one parameter (s.substring(9)) or make the second parameter the last index + 1, which is 16. Therefore, I and III are the correct options. \n", "question": "If the string \u201ccomputer science\u201d is assigned to the variable s, which of the following will return the string \u201cscience\u201d?\n                \n      I. s.substring(9);\n     II. s.substring(9, 15);\n    III. s.substring(9, 16);\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n II only \n\n", "\n III only \n\n", "\n I and III   \n\n", "\n I and II\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "This question is very simple. doSomething replaces the values of the array with the indices of the array (i denotes the index). Therefore, after doSomething(arr) is called, arr would be {0, 1, 2, 3}. arr[1] = 1 and arr[3] = 3, so the correct output is 1 3. \n", "wrong_ans_explanation": "This question is very simple. doSomething replaces the values of the array with the indices of the array (i denotes the index). Therefore, after doSomething(arr) is called, arr would be {0, 1, 2, 3}. arr[1] = 1 and arr[3] = 3, so the correct output is 1 3. \n", "question": "What will be the output of this code program?\n        \n    class Something\n    {\n        public static void main(String[] args)\n        {\n            int[] arr = {1, 2, 3, 4};\n            doSomething(arr);\n            System.out.print(arr[1] + \u201c \u201c);\n            System.out.print(arr[3]);\n        }\n\n\n        public void doSomething(int[] list)\n        {\n            int[] b = list;\n            for (int i = 0; i < b.length; i++)\n                b[i] = i;\n        }\n    }\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0 0 \n\n", "\n 2 4 \n\n", "\n 1 3     \n\n", "\n 0 2 \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "The add method with one parameter just adds the object to the end of the items ArrayList. Therefore, after A, B, and C are added, items will look like this: [A, B, C]. Items.add(0, \u201cD\u201d) adds D at the 0th index and shifts all the other letters to the right. After this is called, items will look like this: [D, A, B, C]. When items.remove(3) is called, the letter at the third index will be removed, so items will look like this: [D, A, B]. Finally, after E is added at the 0th index, items will look like [E, D, A, B], which is the correct answer.\n                ", "wrong_ans_explanation": "The add method with one parameter just adds the object to the end of the items ArrayList. Therefore, after A, B, and C are added, items will look like this: [A, B, C]. Items.add(0, \u201cD\u201d) adds D at the 0th index and shifts all the other letters to the right. After this is called, items will look like this: [D, A, B, C]. When items.remove(3) is called, the letter at the third index will be removed, so items will look like this: [D, A, B]. Finally, after E is added at the 0th index, items will look like [E, D, A, B], which is the correct answer.\n                ", "question": "Consider the following code segment.\n        \n    ArrayList<String> items = new ArrayList<String>();\n    items.add(\u201cA\u201d);\n    items.add(\u201cB\u201d);        \n    items.add(\u201cC\u201d);\n    items.add(0, \u201cD\u201d);\n    items.remove(3);\n    items.add(0, \u201cE\u201d);\n    System.out.println(items);\n\nWhat is the output by the code segment?\n        \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n [A, B, C, E] \n\n", "\n [A, B, D, E] \n\n", "\n [E, D, A, B] \n\n", "\n [E, D, A, C]\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "You could solve this problem by finding every value of k and doing modular arithmetic until k = 10. Or you could realize that since k is added by increments of 2 if k is divisible by 3 and added by increments of 1 if k is not divisible by 3, k % 3  repeatedly oscillates between 0 and 2. For example, when k = 0, k % 3 = 0, so 0 is printed and k is added by 2. Then, k is 2 and k % 3 is now 2, so 2 is printed and k is added by 1. This results in k being 3 and k % 3 = 0, which starts the entire cycle again. Now that the pattern has been realized, we need to understand when we have to stop. Since the last value where k % 3 = 0 is k = 9 (k has to be less than 10), we know that 0 is outputted and k is incremented by 2 after this, which results in k being 11, thus ending the while loop. \n    Therefore, the correct answer out of the answer choices would be 0 2 0 2 0 2 0.\n", "wrong_ans_explanation": "You could solve this problem by finding every value of k and doing modular arithmetic until k = 10. Or you could realize that since k is added by increments of 2 if k is divisible by 3 and added by increments of 1 if k is not divisible by 3, k % 3  repeatedly oscillates between 0 and 2. For example, when k = 0, k % 3 = 0, so 0 is printed and k is added by 2. Then, k is 2 and k % 3 is now 2, so 2 is printed and k is added by 1. This results in k being 3 and k % 3 = 0, which starts the entire cycle again. Now that the pattern has been realized, we need to understand when we have to stop. Since the last value where k % 3 = 0 is k = 9 (k has to be less than 10), we know that 0 is outputted and k is incremented by 2 after this, which results in k being 11, thus ending the while loop. \n    Therefore, the correct answer out of the answer choices would be 0 2 0 2 0 2 0.\n", "question": "Consider the following code segment.\n        \n    int k = 0; \n    while (k < 10)\n    {\n        System.out.print((k % 3) + \u201c \u201c);\n        if ((k % 3) == 0)\n            k = k + 2;\n        else\n            k++;\n    }\n\nWhat is printed as a result of executing the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0 2 1 0 2 \n\n", "\n 0 2 0 2 0 2 \n\n", "\n 0 2 1 0 2 1 0 \n\n", "\n 0 2 0 2 0 2 0            \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "The first part of the expression, !( a < b ) is equivalent to saying a >= b. The second part of the expression, !( a > b ) is equivalent to saying a <= b. Since an AND statement connects these two statements, the only possible values that would satisfy both parts of the expression would be if a == b.\n", "wrong_ans_explanation": "The first part of the expression, !( a < b ) is equivalent to saying a >= b. The second part of the expression, !( a > b ) is equivalent to saying a <= b. Since an AND statement connects these two statements, the only possible values that would satisfy both parts of the expression would be if a == b.\n", "question": "Assume that a and b are variables of type int. The expression \n                \n    !( a < b ) && !( a > b ) \n        \nis equivalent to which of the following?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n true\n\n", "\n false\n\n", "\n a == b \n\n", "\n a != b \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Since k is added by 2 every iteration, x essentially adds up every second value in arr. x would equal arr[0] + arr[2] + arr[4] + arr[6]. This is equal to 3 + 1  + 1 + 2 = 7. Therefore, mystery(num) would return 7.\n", "wrong_ans_explanation": "Since k is added by 2 every iteration, x essentially adds up every second value in arr. x would equal arr[0] + arr[2] + arr[4] + arr[6]. This is equal to 3 + 1  + 1 + 2 = 7. Therefore, mystery(num) would return 7.\n", "question": "Consider the following method.\n\n    public static int mystery(int[] arr)\n    {\n        int x = 0;\n        for (int k = 0; k < arr.length; k = k + 2)\n            x = x + arr[k];\n        return x;\n    }\n\nAssume that the array num has been declared and initialized as follows. \n\n    int[] num = {3, 6, 1, 0, 1, 4, 2};\n\nWhat value will be returned as a result of the call mystery(num)?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 5\n\n", "\n 6\n\n", "\n 7 \n\n", "\n 10 \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Something to memorize ( Mnemonic: i4f4d8 ...I am a fan of Falcons, I will remember the mnemonic as \u2018I root for Falcons\u2019...thus i4f and double is 4 times 2)... The size of an int is 4 bytes, the size of a float is 4 bytes, and since doubles have a larger size than both these primitive types, the size of a double has to be 8 bytes.\n", "wrong_ans_explanation": "Something to memorize ( Mnemonic: i4f4d8 ...I am a fan of Falcons, I will remember the mnemonic as \u2018I root for Falcons\u2019...thus i4f and double is 4 times 2)... The size of an int is 4 bytes, the size of a float is 4 bytes, and since doubles have a larger size than both these primitive types, the size of a double has to be 8 bytes.\n", "question": "What is the size of a double variable in Java?\n        \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 2 bytes\n\n", "\n 4 bytes\n\n", "\n 8 bytes\n\n", "\n It depends on the compiler setting \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Don\u2019t worry, you do not have to do 50 iterations to find the value of n. However, we still must find n after a few iterations to determine the correct answer. In this for loop, n is being added by 3 and then divided by 2 for 50 iterations. (Remember: Since n is an int, we must always round down when dividing.) So, (2005 + 3) / 2 = 1004, (1004 + 3) / 2 = 503, (503 + 3) / 2 = 253, (253 + 3) / 2 = 128, (128 + 3) / 2 = 65, (65 + 3) / 2 = 34, (34 + 3) / 2 = 18, (18 + 3) / 2 = 10, (10 + 3) / 2 = 6, (6 + 3) / 2 = 4, and finally, (4 + 3) / 2 = 3. Although these aren\u2019t 50 iterations, as you can see if you try to do (3 + 3) / 2, you will keep receiving 3. Therefore, the rest of the iterations are redundant, so you are left with n being 3. \n", "wrong_ans_explanation": "Don\u2019t worry, you do not have to do 50 iterations to find the value of n. However, we still must find n after a few iterations to determine the correct answer. In this for loop, n is being added by 3 and then divided by 2 for 50 iterations. (Remember: Since n is an int, we must always round down when dividing.) So, (2005 + 3) / 2 = 1004, (1004 + 3) / 2 = 503, (503 + 3) / 2 = 253, (253 + 3) / 2 = 128, (128 + 3) / 2 = 65, (65 + 3) / 2 = 34, (34 + 3) / 2 = 18, (18 + 3) / 2 = 10, (10 + 3) / 2 = 6, (6 + 3) / 2 = 4, and finally, (4 + 3) / 2 = 3. Although these aren\u2019t 50 iterations, as you can see if you try to do (3 + 3) / 2, you will keep receiving 3. Therefore, the rest of the iterations are redundant, so you are left with n being 3. \n", "question": "What is the value of n after the following code is executed?\n        \n    int n = 2005;\n    for (int j = 0; j < 50; j++)\n        n = (n + 3) / 2; \n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0\n\n", "\n 1\n\n", "\n 2\n\n", "\n 3 \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "If d1 and d2 are considered equal according to almostEqual, then this means that the difference between d1 and d2 is less than or equal to the tolerance value. However, an absolute value must be used because d2 could be greater than d1, which would result in (d1 - d2) being negative. Therefore, the correct code should be:\n        \n    return Math.abs(d1 - d2) <= tolerance;  \n", "wrong_ans_explanation": "If d1 and d2 are considered equal according to almostEqual, then this means that the difference between d1 and d2 is less than or equal to the tolerance value. However, an absolute value must be used because d2 could be greater than d1, which would result in (d1 - d2) being negative. Therefore, the correct code should be:\n        \n    return Math.abs(d1 - d2) <= tolerance;  \n", "question": "Consider the following method that is intended to determine if the double values d1 and d2 are close enough to be considered equal. For example, given a tolerance of 0.001, the values 54.32271 and 54.32294 would be considered equal.\n        \n    /* return true if d1 and d2 are within the specified tolerance, false otherwise */\n\n    public boolean almostEqual(double d1, double d2, double tolerance)\n    {\n            /* missing code */\n    }\n\nWhich of the following should replace /* missing code */ so that almostEqual will work as intended?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n return ((d1 + d2) / 2) <= tolerance;\n\n", "\n return (d1 - d2) >= tolerance;\n\n", "\n return ((d1 + d2) / 2) >= tolerance;\n\n", "\n return Math.abs(d1 - d2) <= tolerance; \n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "To find the sum of the elements in the array key, we must add up the individual values of each index in key. Therefore, it would seem that the sum should be:\n\n    sum += key[j];\n\nHowever, since j begins at 1 and ends at key.length, this code would return an IndexOutOfBoundsException. Therefore, to accommodate, the correct line of code should be:\n\n    sum += key[j - 1];\n", "wrong_ans_explanation": "To find the sum of the elements in the array key, we must add up the individual values of each index in key. Therefore, it would seem that the sum should be:\n\n    sum += key[j];\n\nHowever, since j begins at 1 and ends at key.length, this code would return an IndexOutOfBoundsException. Therefore, to accommodate, the correct line of code should be:\n\n    sum += key[j - 1];\n", "question": "Consider the following method that is intended to return the sum of the elements in the array key.\n                \n    public static int sumArray(int[] key)\n    {\n        int sum = 0;\n        for (int j = 1; j <= key.length; j++)\n        {\n            /* missing code */\n        }\n        return sum;\n    }\n\nWhich of the following statements should be used to replace /* missing code */ so that sumArray will work as intended?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n sum = key[j];\n\n", "\n sum += key[j - 1]; \n\n", "\n sum += key[j];\n\n", "\n sum += sum + key[j - 1];\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "This question requires you look at the intricacies of for loops. Since the contents of a1 end at index a1.length - 1 (since j < a1.length), a2 must start at a1.length. Therefore, the contents of a2 must be positioned at indices k + a1.length.\n", "wrong_ans_explanation": "This question requires you look at the intricacies of for loops. Since the contents of a1 end at index a1.length - 1 (since j < a1.length), a2 must start at a1.length. Therefore, the contents of a2 must be positioned at indices k + a1.length.\n", "question": "Consider the following incomplete method that is intended to return an array that contains the contents of its first array parameter followed by the contents of its second array parameter.\n                \n    public static int[] add(int[] a1, int[] a2)\n    {\n        int[] result = new int[a1.length + a2.length];\n        for (int j = 0; j < a1.length; j++)\n            result[j] = a1[j];\n        for (int k = 0; k < a2.length; k++)\n            result[  /*  index  */  ] = a2[k];        \n        return result;\n     }\n                \nWhich of the following expressions can be used to replace /*  index  */ so that add will work as intended?\n        \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n k\n\n", "\n k + a1.length - 1\n\n", "\n k + a1.length        \n\n", "\n k + a1.length + 1\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The .compareTo() method compares two strings lexicographically (A.K.A. according to Unicode). If the first string appears first in an alphabetized list, then this .compareTo() method would return a negative number. Therefore, to find the index of the word that appears first in an alphabetized list, you would have to make sure that this word would return a negative number in the .compareTo() method when compared to all the other words in the array of Strings. As a result, the condition in the for loop should be:\n\n    words[index].compareTo(words[minPos]) < 0 \n ", "wrong_ans_explanation": "The .compareTo() method compares two strings lexicographically (A.K.A. according to Unicode). If the first string appears first in an alphabetized list, then this .compareTo() method would return a negative number. Therefore, to find the index of the word that appears first in an alphabetized list, you would have to make sure that this word would return a negative number in the .compareTo() method when compared to all the other words in the array of Strings. As a result, the condition in the for loop should be:\n\n    words[index].compareTo(words[minPos]) < 0 \n ", "question": "The following method is intended to return the index to the \u201csmallest\u201d word, namely, the word that would appear first in an alphabetized list.\n        \n    //Precondition: words is initialized with lowercase words.\n    //              words.length > 0\n\n    public static int findMin(String[] words)\n    {\n        int minPos = 0;\n        for (int index = 1; index < words.length; index++)\n        {\n            if ( /* condition */ )\n            {\n                minPos = index;\n            }        \n        }\n        return minPos;\n    }\n        \nWhich of the following should be used to replace /* condition */  so that findMin works as intended?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n words[index] > words[minPos]\n\n", "\n words[index].compareTo(words[minPos]) > 0 \n\n", "\n words[index].compareTo(words[minPos]) >= 0 \n\n", "\n words[index].compareTo(words[minPos]) < 0 \n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Let A = (x && y). Then the expression, \n\n    (x && y) || !(x && y) is equal to A || !A.\n\nSince either A or !A always has to be true, this expression must always evaluate to true.\n", "wrong_ans_explanation": "Let A = (x && y). Then the expression, \n\n    (x && y) || !(x && y) is equal to A || !A.\n\nSince either A or !A always has to be true, this expression must always evaluate to true.\n", "question": "Assume that x and y are Boolean variables and have been properly initialized. \n                \n    (x && y) || !(x && y)\n        \nThe result of evaluating the expression above is best described as\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n always true           \n\n", "\n always false\n\n", "\n true only when x is true and y is true\n\n", "\n true only when x and y have the same value\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Since the iteration of value (value++) comes after the printing of value, the first number that will be printed is the initial value of value( no pun intended ). Since value has to be less than 28 in order for it to be printed, the last number that will be printed is 27. \n", "wrong_ans_explanation": "Since the iteration of value (value++) comes after the printing of value, the first number that will be printed is the initial value of value( no pun intended ). Since value has to be less than 28 in order for it to be printed, the last number that will be printed is 27. \n", "question": "Consider the following code segment. \n        \n    int value = 15;\n    while (value < 28)\n    {\n        System.out.println(value);\n        value++;\n    }\n        \nWhat are the first and last numbers output by the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n First: 15       Last: 27            \n\n", "\n First: 15       Last: 28\n\n", "\n First: 16       Last: 27 \n\n", "\n First: 16       Last: 28\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Since k is a random number from 1 to n, the minimum number of times that Hello will be printed is when k is 1 (at its minimum). If k = 1, then the code inside the for loop will never execute since p <= k for this to occur(p = 2 and k = 1). Since the code inside the for loop will never execute, then Hello will be printed a minimum of 0 times. \n", "wrong_ans_explanation": "Since k is a random number from 1 to n, the minimum number of times that Hello will be printed is when k is 1 (at its minimum). If k = 1, then the code inside the for loop will never execute since p <= k for this to occur(p = 2 and k = 1). Since the code inside the for loop will never execute, then Hello will be printed a minimum of 0 times. \n", "question": "Consider the following code segment. \n                \n    int k = [a random number such that 1 <= k <= n];\n\n    for (int p = 2; p <= k; p++)\n        for (int r = 1; r < k; r++)\n            System.out.println(\u201cHello\u201d);\n        \nWhat is the minimum number of times that Hello will be printed?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0         \n \n", "\n 1\n\n", "\n n - 1 \n\n", "\n n - 2\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Option I would correctly return the sum of all values in sums because total adds up the values in nums from index 0 to nums.length - 1, which is correct. Option II is incorrect because the for loop begins at index nums.length, which would provide an IndexOutOfBoundsException. Option III is correct because this code is a transmutation from the for loop in Option I to this while loop. Since the while loop iterates from the 0th index to mums.length - 1, it behaves exactly like the for loop in Option I, and therefore is also correct. Option I and Option III are correct.\n        ", "wrong_ans_explanation": "Option I would correctly return the sum of all values in sums because total adds up the values in nums from index 0 to nums.length - 1, which is correct. Option II is incorrect because the for loop begins at index nums.length, which would provide an IndexOutOfBoundsException. Option III is correct because this code is a transmutation from the for loop in Option I to this while loop. Since the while loop iterates from the 0th index to mums.length - 1, it behaves exactly like the for loop in Option I, and therefore is also correct. Option I and Option III are correct.\n        ", "question": "Consider the following instance variable and incomplete method. The method total is intended to return the sum of all values in nums.\n        \n    private int[] nums;\n\n    public int total()\n    {\n        int total = 0;\n        /* missing code */\n        return total;\n    }\n                \nWhich of the code segments shown below can be used to replace /* missing code */ so that total will work as intended?\n                \n      I. for (int pos = 0; pos < nums.length; pos++)\n         {        \n             total += nums[pos];\n         }\n\n     II. for (int pos = nums.length; pos > 0; pos--)\n         {\n             total += nums[pos];\n         }\n\n    III. int pos = 0;\n         while (pos < nums.length)\n         {        \n             total += nums[pos];\n             pos++;\n         }                                 \n                \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n II only\n\n", "\n III only\n\n", "\n I and III         \n \n", "\n II and III \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "If you can understand what code segment is attempting to do, you can very easily acquire the answer. This code segment is moving the values in oldArray into a double array, newArray. As seen from row++, the values are being added by column (vertically downwards) until it hits the end of the column \u2014 that is, when row % 3 = 0. Then, if the column is filled, col++ and row = 0 is called, which means that the values are now being added in the next column starting from the 0th row. Therefore, newArray would look like this:\n\n    1 4 7\n    2 5 8\n    3 6 9\n\nAs you can see, newArray[0][2] would be 7. \n", "wrong_ans_explanation": "If you can understand what code segment is attempting to do, you can very easily acquire the answer. This code segment is moving the values in oldArray into a double array, newArray. As seen from row++, the values are being added by column (vertically downwards) until it hits the end of the column \u2014 that is, when row % 3 = 0. Then, if the column is filled, col++ and row = 0 is called, which means that the values are now being added in the next column starting from the 0th row. Therefore, newArray would look like this:\n\n    1 4 7\n    2 5 8\n    3 6 9\n\nAs you can see, newArray[0][2] would be 7. \n", "question": "Consider the following code segment.\n        \n    int[] oldArray = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int[][] newArray = new int[3][3];\n    int row = 0;\n    int col = 0;\n    for (int value : oldArray)\n    {        \n        newArray[row][col] = value;\n        row++;\n        if ((row % 3) == 0)\n        {\n            col++;\n            row = 0;\n        }        \n    }\n    System.out.println(newArray[0][2]);\n        \nWhat is printed as a result of executing the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 8\n\n", "\n 4\n\n", "\n 7 \n \n", "\n 3\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The code segment stated in the question prints all the numbers between 1 and 100 that are divisible by 4. This is the same as printing out every number from 4 to 100 in arithmetic steps of 4. Therefore, the code segment that will produce the same output would be:\n\n    for (int k = 4; k <= 100; k = k + 4)            \n        System.out.println(k);\n", "wrong_ans_explanation": "The code segment stated in the question prints all the numbers between 1 and 100 that are divisible by 4. This is the same as printing out every number from 4 to 100 in arithmetic steps of 4. Therefore, the code segment that will produce the same output would be:\n\n    for (int k = 4; k <= 100; k = k + 4)            \n        System.out.println(k);\n", "question": "Consider the following code segment.\n\n    for (int k = 1; k <= 100; k++)\n        if ((k % 4) == 0)\n            System.out.println(k);\n        \nWhich of the following code segments will produce the same output as the code segment above?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n for (int k = 4; k <= 25; k = 4 * k)\n       System.out.println(k); \n\n", "\n for (int k = 1; k <= 25; k++)\n       System.out.println(k);\n\n", "\n for (int k = 1; k <= 100; k = k + 4)\n       System.out.println(k);\n\n", "\n for (int k = 4; k <= 100; k = k + 4)             \n       System.out.println(k);\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "In the first iteration of the while loop, result = 0 * 10 + 2574 % 10 = 4 and num = 2574 / 10 = 257. In the second iteration of the while loop, result = 4 * 10 + 257 % 10 = 47 and num = 257 / 10 = 25. You can probably see where this is going. This method aims to reverse num. Therefore, 4752 is printed as a result of executing the code segment.\n", "wrong_ans_explanation": "In the first iteration of the while loop, result = 0 * 10 + 2574 % 10 = 4 and num = 2574 / 10 = 257. In the second iteration of the while loop, result = 4 * 10 + 257 % 10 = 47 and num = 257 / 10 = 25. You can probably see where this is going. This method aims to reverse num. Therefore, 4752 is printed as a result of executing the code segment.\n", "question": "Consider the following code segment.\n        \n    int num = 2574;\n    int result = 0;\n    while (num > 0)\n    {\n        result = result * 10 + num % 10;\n        num /= 10;\n    }\n    System.out.println(result);\n        \nWhat is printed as a result of executing the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 4\n\n", "\n 2574\n\n", "\n 18\n\n", "\n 4752       \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "To find the number of lines this code segment will produce, you just have to find how many times it takes to divide 50 by 2 to reach 0. 50 / 2 = 25, 25 / 2 = 12, 12 / 2 = 6, 6 / 2 = 3, 3 / 2 = 1, and 1 / 2 = 0. Since this took 6 iterations, 6 lines of output will be produced by this segment.\n", "wrong_ans_explanation": "To find the number of lines this code segment will produce, you just have to find how many times it takes to divide 50 by 2 to reach 0. 50 / 2 = 25, 25 / 2 = 12, 12 / 2 = 6, 6 / 2 = 3, 3 / 2 = 1, and 1 / 2 = 0. Since this took 6 iterations, 6 lines of output will be produced by this segment.\n", "question": "Refer to the following program segment. \n                \n    for (int k = 50; k > 0; k = k / 2)\n        System.out.println(k);\n        \nHow many lines of output will this segment produce?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 50\n\n", "\n 49        \n\n", "\n 7\n\n", "\n 6        \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "The .set(x, y) method for ArrayList<String> replaces the value at index x with the string y. Therefore, option I (someList.set(2, \u201c6\u201d);) will not cause an error to occur. Option II also will not cause an error to occur because although index 4 is out of the bounds, when used in a .add() method, it is perfectly fine. This code in option II will add the word \u201cPat\u201d at the end of the ArrayList. Since the .get(x) method retrieves the value at index x, option III will cause an error to occur because the 4th index does not have a value in someList. Therefore, only option III will cause an error message to appear.\n        ", "wrong_ans_explanation": "The .set(x, y) method for ArrayList<String> replaces the value at index x with the string y. Therefore, option I (someList.set(2, \u201c6\u201d);) will not cause an error to occur. Option II also will not cause an error to occur because although index 4 is out of the bounds, when used in a .add() method, it is perfectly fine. This code in option II will add the word \u201cPat\u201d at the end of the ArrayList. Since the .get(x) method retrieves the value at index x, option III will cause an error to occur because the 4th index does not have a value in someList. Therefore, only option III will cause an error message to appear.\n        ", "question": "Let someList be an ArrayList<String> containing only these elements:\n                        \n    \u201cJoe\u201d, \u201cJudy\u201d, \u201cJack\u201d, \u201cJames\u201d\n        \nWhich of the following statements will cause an error to occur?\n\n      I. someList.set(2, \u201c6\u201d);\n     II. someList.add(4, \u201cPat\u201d);\n    III. String s = someList.get(4);\n        \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only \n\n", "\n II and III only\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "Since this sequentialSearch method is recursive, we need to know when to stop this recursion. One way this recursion ends is if target is found in data and the index is returned. But what if this target value is not found? Then last will keep decreasing and eventually be less than 0. To avoid this IndexOutOfBoundsException, we must place a condition that returns -1 if last is less than 0. It will look like this:\n        \n    if (last < 0)               \n        return -1; \n", "wrong_ans_explanation": "Since this sequentialSearch method is recursive, we need to know when to stop this recursion. One way this recursion ends is if target is found in data and the index is returned. But what if this target value is not found? Then last will keep decreasing and eventually be less than 0. To avoid this IndexOutOfBoundsException, we must place a condition that returns -1 if last is less than 0. It will look like this:\n        \n    if (last < 0)               \n        return -1; \n", "question": "Consider the following instance variable and methods. You may assume that data has been initialized with length > 0. The methods are intended to return the index of an array element equal to target, or -1, if no such element exists.\n        \n    private int[] data;\n\n    public int seqSearch(int target)\n    {\n        return seqSearchHelper(target, data.length - 1);\n    }\n\n    private int seqSearchHelper(int target, int last)\n    {\n        // Line 1\n        if (data[last] == target)\n            return last;\n        else\n            return seqSearchHelper(target, last - 1);\n    }\n        \nWhich of the following should be used to replace // Line 1 in seqSearchHelper so that seqSearch will work as intended?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n if (last <= 0)      return -1;\n\n", "\n if (last < 0)      return -1;          \n\n", "\n if (last <= 0)      return -1;\n\n", "\n while (last >= 0)                \n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "Since the for loop above iterates from 0 to 20 in steps of 2 and prints only if the value % 3 == 1, then only even numbers from 0 to 20 that have a remainder of 1 when divided by 3 will be printed. Therefore, 4, 10, and 16 will be printed.\n        ", "wrong_ans_explanation": "Since the for loop above iterates from 0 to 20 in steps of 2 and prints only if the value % 3 == 1, then only even numbers from 0 to 20 that have a remainder of 1 when divided by 3 will be printed. Therefore, 4, 10, and 16 will be printed.\n        ", "question": "Consider the following code segment.\n        \n    for (int j = 0; j < 20; j = j + 2)\n    {\n        if (j % 3 == 1)\n            System.out.print(j + \u201c \u201c);\n    }\n                \nWhat is printed as a result of executing the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 0 6 12 18\n\n", "\n 4 10 16           \n\n", "\n 1 4 7 10 13 16 19\n\n", "\n 0 2 4 6 8 10 12 14 16 18 \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Since each bus has a fixed amount of doors, an absence or presence of air conditioning, and an average number of miles per gallon, only one class is needed. Although these numbers are variable, they are fixed for each bus, so the most efficient design would be to declare each of these variables as data fields, where the number of doors is an int, the presence of air conditioning is a boolean, and the amount of average miles per gallon is a double. \n", "wrong_ans_explanation": "Since each bus has a fixed amount of doors, an absence or presence of air conditioning, and an average number of miles per gallon, only one class is needed. Although these numbers are variable, they are fixed for each bus, so the most efficient design would be to declare each of these variables as data fields, where the number of doors is an int, the presence of air conditioning is a boolean, and the amount of average miles per gallon is a double. \n", "question": "A bus dealership needs a program to store information about the buses for sale. For each bus, they want to keep track of the following information: number of doors, whether the bus has air conditioning, and its average number of miles per gallon. Which of the following is the best design?\n                \n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n Use a class Bus which has three subclasses: Doors, AirConditioning, and MilesPerGallon.\n\n", "\n Use a class Bus, which has a subclass Doors, with a subclass AirConditioning, with a subclass MilesPerGallon.\n\n", "\n Use three classes: Doors, AirConditioning, and MilesPerGallon, each with a subclass Bus.\n\n", "\n Use one class Bus, which has three data fields: int numDoors, boolean hasAir, and double milesPerGallon.   \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Since fido is an underdog, we must go to the act() method in the Underdog class. This method first asks us to execute super.act(), which means we must revert back to the parent class .act() method. This method first prints \u201crun,\u201d then calls the eat() method. Remember: Fido is an underdog, so we are actually calling the Underdog\u2019s eat() method. In this eat() method, super.eat() is called, so we must print \u201ceat,\u201d as stated in the Dog\u2019s eat() method. Then, we go back to Underdog\u2019s eat() method and print \u201cbark.\u201d After this, we go back to finish executing the Underdog\u2019s act() method, and print \u201csleep.\u201d Altogether, as a result of calling fido.act(), this is printed:\n\n    run eat bark sleep\n                ", "wrong_ans_explanation": "Since fido is an underdog, we must go to the act() method in the Underdog class. This method first asks us to execute super.act(), which means we must revert back to the parent class .act() method. This method first prints \u201crun,\u201d then calls the eat() method. Remember: Fido is an underdog, so we are actually calling the Underdog\u2019s eat() method. In this eat() method, super.eat() is called, so we must print \u201ceat,\u201d as stated in the Dog\u2019s eat() method. Then, we go back to Underdog\u2019s eat() method and print \u201cbark.\u201d After this, we go back to finish executing the Underdog\u2019s act() method, and print \u201csleep.\u201d Altogether, as a result of calling fido.act(), this is printed:\n\n    run eat bark sleep\n                ", "question": "Consider the following two classes.\n                         \n    public class Dog\n    {\n        public void act()\n        {\n            System.out.print(\u201crun\u201d);\n            eat();\n        }\n\n        public void eat()\n        {\n            System.out.print(\u201ceat\u201d);\n        }\n    }\n\n    public class UnderDog extends Dog\n    {\n        public void act()\n        {\n            super.act();\n            System.out.print(\u201csleep\u201d);\n        }        \n\n        public void eat()\n        {\n            super.eat();\n            System.out.print(\u201cbark\u201d);\n        }\n    }\n                \nAssume that the following declaration appears in a client program. \n\n    Dog fido = new Underdog();\n\nWhat is printed as a result of the call fido.act()?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n run eat \n\n", "\n run eat sleep\n\n", "\n run eat bark sleep        \n\n", "\n run eat sleep bark\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "When dealing with recursive methods, it is easier and less time-consuming to find a pattern to the method. Since 3 is multiplied to the answer every time n is not 0, we just have to calculate how many times the method recurs until n is 0. Since n is subtracted by 1 every time n does not equal 0, the recursive method occurs 5 times. Therefore, 3 is multiplied by 1 (when n = 0, 1 is returned) 5 times. 3^5 = 243. As a result, 243 is returned.\n        ", "wrong_ans_explanation": "When dealing with recursive methods, it is easier and less time-consuming to find a pattern to the method. Since 3 is multiplied to the answer every time n is not 0, we just have to calculate how many times the method recurs until n is 0. Since n is subtracted by 1 every time n does not equal 0, the recursive method occurs 5 times. Therefore, 3 is multiplied by 1 (when n = 0, 1 is returned) 5 times. 3^5 = 243. As a result, 243 is returned.\n        ", "question": "Consider the following recursive method. \n        \n    public static int mystery(int n)\n    {\n        if (n == 0)\n            return 1;\n        else\n            return 3 * mystery(n - 1);\n    }\n                \nWhat value is returned as a result of the call mystery(5)?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 3 \n\n", "\n 81\n\n", "\n 243 \n\n", "\n 6561 \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The AP loves asking questions like these which tests your knowledge about the purpose of a code segment given to you. In this method, the for loop iterates throughout the entire array and if a value in the array is greater than the value of loc, then this value becomes loc. Therefore, by the time the for loop iterates throughout the entire array, loc would have stored the index of the largest value in array vals. That is the postcondition of of the check() method. \n                ", "wrong_ans_explanation": "The AP loves asking questions like these which tests your knowledge about the purpose of a code segment given to you. In this method, the for loop iterates throughout the entire array and if a value in the array is greater than the value of loc, then this value becomes loc. Therefore, by the time the for loop iterates throughout the entire array, loc would have stored the index of the largest value in array vals. That is the postcondition of of the check() method. \n                ", "question": "Consider the following instance variable and method.\n        \n    private int[] vals;\n\n    // Precondition: vals.length > 0\n    public int check()\n    {        \n        int loc = vals.length / 2;\n\n        for (int j = 0; j < vals.length; j++)\n        {        \n            if (vals[j] > vals[loc];\n                loc = j;\n        }\n        return loc;\n    }\n                \nWhich of the following is the best postcondition for check?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n returns the index of the last element in array vals whose value is greater than vals[loc]\n\n", "\n returns the index of the first element in array vals whose value is greater than vals[loc]\n\n", "\n returns the index of the largest value in the second half of array vals\n\n", "\n returns the index of the largest value in array vals \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Method overriding, in object-oriented programming, is a language feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its parent classes. This is apparent in the question because method1() in Class1 and Class2 both have the same names, return types, and signatures while having different implementations. Remember: Method overriding occurs in a child and parent class while method overloading usually occurs in one class. Since method1() is seen in different classes, method overriding is being used. \n", "wrong_ans_explanation": "Method overriding, in object-oriented programming, is a language feature that allows a subclass to provide a specific implementation of a method that is already provided by one of its parent classes. This is apparent in the question because method1() in Class1 and Class2 both have the same names, return types, and signatures while having different implementations. Remember: Method overriding occurs in a child and parent class while method overloading usually occurs in one class. Since method1() is seen in different classes, method overriding is being used. \n", "question": "Refer to the classes below.\n\n    public class Class1\n    {\n        // default constructor not shown \u2026\n\n        public void method1()\n        { /* implementation of method1 */ }\n    }\n\n    public class Class2 extends Class1\n    {\n        // default constructor not shown \u2026\n\n        public void method1()\n        { /* different implementation from method1 in Class1 */ }\n\n        public void method2()\n        { /* implementation of method2 */ }\n    }\n\nThe method1 in Class2 is an example of \n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n method overloading     \n\n", "\n polymorphism \n\n", "\n method overriding    \n\n", "\n information hiding\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Option II would not give an error because method2() is a function within Class2 and b is an instance of Class2. Option III would not give an error because although a is not an instance of Class 2, it is cast to Class2 accurately, and therefore it can call method2() without error. However, option I does cause an error because a is an instance of Class1, and therefore cannot call method2(). Altogether, only option I causes an error message to appear.  \n", "wrong_ans_explanation": "Option II would not give an error because method2() is a function within Class2 and b is an instance of Class2. Option III would not give an error because although a is not an instance of Class 2, it is cast to Class2 accurately, and therefore it can call method2() without error. However, option I does cause an error because a is an instance of Class1, and therefore cannot call method2(). Altogether, only option I causes an error message to appear.  \n", "question": "Refer to the classes below.\n\n    public class Class1\n    {\n        // default constructor not shown \u2026\n\n        public void method1()\n        { /* implementation of method1 */ }\n    }\n\n    public class Class2 extends Class1\n    {\n        // default constructor not shown \u2026\n\n        public void method1()\n        { /* different implementation from method1 in Class1 */ }\n\n        public void method2()\n        { /* implementation of method2 */ }\n    }\n\t\nConsider the following declarations in a client class.\n\n    Class1 a = new Class1();\n    Class2 b = new Class2();\n\nWhich of the following method calls will cause an error?\n\n      I. a.method2();\t\n     II. b.method2();\t\n    III. ( (Class2) a ).method2();\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n I only \n\n", "\n II only\n\n", "\n III only\n\n", "\n I and III only\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Overloading occurs when two or more methods in one class have the same method name but different parameters. The names of the parameters do not matter; however, the number and types of parameters do matter when considering to overload two methods within the same class. Therefore, the statement that \u201cTwo overloaded methods in the same class must have parameters with different names.\u201d is false.  \n", "wrong_ans_explanation": "Overloading occurs when two or more methods in one class have the same method name but different parameters. The names of the parameters do not matter; however, the number and types of parameters do matter when considering to overload two methods within the same class. Therefore, the statement that \u201cTwo overloaded methods in the same class must have parameters with different names.\u201d is false.  \n", "question": "Which statement about parameters is false?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n The scope of parameters is the method in which they are defined.\n\n", "\n Static methods have no implicit parameter this.\n\n", "\n Two overloaded methods in the same class must have parameters with different names. \n\n", "\n All parameters in Java are passed by value.\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "Static methods are created with the aim to be shared among all Objects created from the same class. Therefore, x, y, and a will share the same value whenever the static method something is called. When something(y) is called, x becomes 8. Because of the static property, x, y, and a all become 8. After something(x) is called, a becomes 9, and so do y and a. As a result, the values of x, y, and a are 9, 9, and 9.\n", "wrong_ans_explanation": "Static methods are created with the aim to be shared among all Objects created from the same class. Therefore, x, y, and a will share the same value whenever the static method something is called. When something(y) is called, x becomes 8. Because of the static property, x, y, and a all become 8. After something(x) is called, a becomes 9, and so do y and a. As a result, the values of x, y, and a are 9, 9, and 9.\n", "question": "This question refers to the following class.\n\n    public class Object\n    {\n        private int num;\n\n        public Object() \t\t//default constructor\n        { num = 0; }\n\n        public Object(int n)\t\t//constructor\n        { num = n; }\n\n        public void increment()\t//increment by 1\n        { num++; }\n    }\n\nHere is a client program that uses this class.\n\n    public class ObjectTest\n    {\n        public static Object something(Object obj)\n        {\n            Object o = obj;\n            o.increment();\n            return o;\n        }\n\n        public static void main(String[] args)\n        {\n            Object x = new Object(2);\n            Object y = new Object(7);\n            Object a = y;\n            x = something(y);\n            a = something(x);\n        }\n    }\n\n    Just before exiting this program, what are the object values of x, y, and a, respectively?\t\n\n    ", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n 2, 9, 9 \n\n", "\n 9, 9, 9 \n\n", "\n 2, 8, 9 \n\n", "\n 7, 8, 9\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "The intent of the teacher/programmer is to output (C. Average score). However, since else is not used, each of the if statements will be executed and two lines will be printed. The first is printed when the program passes the if (score >= 70.0) test, the second when it passes the if (score >= 60.0) test. \nThe programmer can avoid this either by using a sequence of else if tests, thus excluding all other tests when one is found to be true, or by returning the appropriate string (with a return statement) as soon as a test is true.\n", "wrong_ans_explanation": "The intent of the teacher/programmer is to output (C. Average score). However, since else is not used, each of the if statements will be executed and two lines will be printed. The first is printed when the program passes the if (score >= 70.0) test, the second when it passes the if (score >= 60.0) test. \nThe programmer can avoid this either by using a sequence of else if tests, thus excluding all other tests when one is found to be true, or by returning the appropriate string (with a return statement) as soon as a test is true.\n", "question": "The intent of a class teacher is to print a student's test score as a letter grade. Test score can be any real number between 0 and 100.\n\n    public class TestReport\n    {\n        private double score;\n\n        //Constructor. Sets score to the specified value.\n        public TestReport(double value)\n        { score = value; }\n\n        //Prints grade and comment.\n        public void printGrade()\n        {\n            if (score >= 90.0)\n                System.out.println(\"A. Congratulations!\");\n            if (score >= 80.0)\n                System.out.println(\"B. Good job.\");\n            if (score >= 70.0)\n                System.out.println(\"C. Average score.\");\n            if (score >= 60.0)\n                System.out.println(\"D. Barely passing.\");\n            if (score < 60.0)\n                System.out.println(\"F. Failing score.\");\n        }\n    }\n\nConsider the following segment of a client program.\n\n    double testScore = IO.readInput();    //read user input\n    TestReport t = new TestReport(testScore);\n    t.printGrade();\n\nIf the user inputs a test score of 75.0, what will be output?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n C. Average score.\n   D. Barely passing.\n   F. Failing score. \n\n", "\n C. Average score. \n   D. Barely passing.\n\n", "\n C. Average score.\n\n", "\n A. Congratulations!\n   B. Good job.\n   C. Average score.\n   \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Statement I is incorrect because when a and b are both false, the expression !a && !b is equivalent to T && T, which is true. Statements II and III are correct because T && F and F && T both evaluate to false.\n", "wrong_ans_explanation": "Statement I is incorrect because when a and b are both false, the expression !a && !b is equivalent to T && T, which is true. Statements II and III are correct because T && F and F && T both evaluate to false.\n", "question": "Suppose a and b are boolean variables. The expression\n\n        !a && !b\n\nwill evaluate to false whenever\n\n         I. a and b are both false.\n         II. a is false and b is true.\n         III. a is true and b is false.\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only\n\n", "\n II and III only\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "The private instance variable total must be incremented by amt. \n\nChoices:\n\n    return total + amt;\n\nand \n\n    return getTotal() + amt;\n\nare wrong because incrementTotal is void and should not return a value. \n\nChoice:\n\n    getTotal() += amt;\n\nis wrong because you can't use a method call as the left-hand side of an assignment. Also, the total is not being changed. \n", "wrong_ans_explanation": "The private instance variable total must be incremented by amt. \n\nChoices:\n\n    return total + amt;\n\nand \n\n    return getTotal() + amt;\n\nare wrong because incrementTotal is void and should not return a value. \n\nChoice:\n\n    getTotal() += amt;\n\nis wrong because you can't use a method call as the left-hand side of an assignment. Also, the total is not being changed. \n", "question": "Refer to the following class: \n\n    public class PiggyBank\n    {\n        private double total;\n        private boolean isFull;\n\n\n        //Increase total by amt.\n        public void incrementTotal(double amt)\n        { /* implementation of incrementTotal */ }\n\n\n        //Change the value of isFull:\n        //If its current value is true, change it to false.\n        //If its current value is false, change it to true.\n        public void changePiggyState()\n        { /* implementation of changePiggyState */ }\n\n\n        //Constructors and other methods not shown.\n    }\n\nAssuming that the PiggyBank class has an accessor method getTotal that returns total, which is a correct /* implementation of incrementTotal */?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n return total + amt;\n\n", "\n return getTotal() + amt;\n\n", "\n total += amt;\n\n", "\n getTotal() += amt;\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The value of the boolean instance variable isFull must be changed to the opposite of what it currently is. Segments I and II both achieve this. Note that !true has a value of false, and !false has a value of true. Segment III fails to do what is required if the current value of isFull is false.\n", "wrong_ans_explanation": "The value of the boolean instance variable isFull must be changed to the opposite of what it currently is. Segments I and II both achieve this. Note that !true has a value of false, and !false has a value of true. Segment III fails to do what is required if the current value of isFull is false.\n", "question": "Refer to the following class:\n\n    public class PiggyBank\n    {\n        private double total;\n        private boolean isFull;\n\n\n        //Increase total by amt.\n        public void incrementTotal(double amt)\n        { /* implementation of incrementTotal */ }\n\n\n        //Change the value of isFull:\n        //If its current value is true, change it to false.\n        //If its current value is false, change it to true.\n        public void changePiggyState()\n        { /* implementation of changePiggyState */ }\n\n\n        //Constructors and other methods not shown.\n    }\n\nWhich is a correct /* implementation of changePiggyState */?\n\n      I. if (isFull)\n            isFull = false;\n         else\n            isFull = true;\n    \n     II. isFull = !isFull;\n\n    III. if (isFull)\n            isFull = !isFull;\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only\n\n", "\n I and II only\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "It doesn't make sense to make an accessor static, because an object will then not be able to invoke that method!\n", "wrong_ans_explanation": "It doesn't make sense to make an accessor static, because an object will then not be able to invoke that method!\n", "question": "Which is a false statement about static methods?\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n A static method can use a static variable in its implementation code.\n\n", "\n If a class is such that it doesn\u2019t make sense to ever create an object of the class, then all methods of that class should be static.\n\n", "\n All methods in a driver class that has a main method should be static.\n\n", "\n Accessor methods in an object may be static, depending on the value that\u2019s been accessed.\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The statement\n\n    double r = Math.random();\n\nproduces a random real number in the range 0.0 to 1.0 such that 0.0 \u2264 r < 1.0. This range can be scaled and shifted.\n\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue:\n\ndouble x = (highValue - lowValue) * Math.random() + lowValue;\n", "wrong_ans_explanation": "The statement\n\n    double r = Math.random();\n\nproduces a random real number in the range 0.0 to 1.0 such that 0.0 \u2264 r < 1.0. This range can be scaled and shifted.\n\nIn general, to produce a random real value in the range lowValue \u2264 x < highValue:\n\ndouble x = (highValue - lowValue) * Math.random() + lowValue;\n", "question": "A programmer needs to produce a random real value x in the range 20.0 \u2264 x < 30.0. A statement that does this correctly is\n\n", "negative_points": "0", "duration_in_seconds": "120", "question_type": "1", "options": ["\n double x = Math.random(20, 30);\n\n", "\n double x = Math.random(30) -10;\n\n", "\n double x = Math.random(20) + 10;\n\n", "\n double x = 10*Math.random() + 20;\n\n"]}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a) \npublic int max (int[] a)\n{\n    int j = 0; \n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] > j)\n            j = a[i];\n    }\n    return j;\n}\n\n(b) \npublic int find(int[] a, int v)\n{\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == v)\n            return i;\n    }\n    return 0;\n}\n\n\n(c)\npublic int[] reverse (int[] a)\n{\n    int[] b = new int[a.length];\n    for (int i = 0; i < b.length, i++)\n    {\n        b[i] = a[a.length - i - 1];  \t\t\n    }\n    return b;\n}\n\n", "wrong_ans_explanation": "(a) \npublic int max (int[] a)\n{\n    int j = 0; \n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] > j)\n            j = a[i];\n    }\n    return j;\n}\n\n(b) \npublic int find(int[] a, int v)\n{\n    for (int i = 0; i < a.length; i++)\n    {\n        if (a[i] == v)\n            return i;\n    }\n    return 0;\n}\n\n\n(c)\npublic int[] reverse (int[] a)\n{\n    int[] b = new int[a.length];\n    for (int i = 0; i < b.length, i++)\n    {\n        b[i] = a[a.length - i - 1];  \t\t\n    }\n    return b;\n}\n\n",        "question": "Write a complete version of the following methods which work on an array of positive integers. Your code may assume that the array contains at least one value, and that all values are positive. \n\n(a) max(int[] a) return the largest value in the array.\n\n(b) find(int[] a, int v) returns the index of the first position which contains the value v. If v is not in the array, return 0.\n\n(c) reverse(int[] a) returns a new array, with the values in reverse order.\n\n",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["\n Compare Your Answer \n\n"], "picture_or_video_name": ""}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a)\npos1 <= array.length -1 &&  pos2 <= array.length - 1\n\n(b)\n{\n    int j= array[pos1]; \n    array[pos1] = array[pos2];\n    array[pos2] = j;\n    success = true;\n}\n\n\n(c)\nexp2 = a.length - i\nexp3 = i", "wrong_ans_explanation": "(a)\npos1 <= array.length -1 &&  pos2 <= array.length - 1\n\n(b)\n{\n    int j= array[pos1]; \n    array[pos1] = array[pos2];\n    array[pos2] = j;\n    success = true;\n}\n\n\n(c)\nexp2 = a.length - i\nexp3 = i",        "question": "Consider the following code, designed to shuffle an array of integers.\n\npublic static boolean swap(int[] array, int pos1, int pos2)\n{\n    boolean success = false; \n    if (<exp1>)\n        <block1> \n    return success;\n}\n\npublic static void shuffle(int[] a)\n{\n    Random random = new Random(); \n    for (int i = 0; i < a.length - 1; i++)\n    {\n        int j = random.nextInt(<exp2>) + <exp3>; \n        swap(a, i - 1, j);\n    }\n}\n\nRecall that random.nextInt(x) returns a random nonnegative integer which is less than x.\n\n(a) The expression exp1 is true if both pos1 and pos2 are valid indices for the array.\nWrite the code for exp1.\n\n(b) The block block1 swaps the values in the array in positions pos1 and pos2.\nWrite the code for block1.\n\n(c) The expressions exp2 and exp3 cause j to be a random valid index which is greater than or equal to i. Find exp2 and exp3.\n\n",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["\n Compare Your Answer \n\n"], "picture_or_video_name": ""}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a) \npublic static int remainder(int n, int m)\n{\n    int r = 0 ;\n    while (n > m)\n    {\n        n = n - m ;\n    }\n    r = n ;\n    return r;\n}\n\n(b) \npublic static int quotient (int n, int m)\n{\n    int q = 0;\n    for (q = 0; n > m; q++)\n    {\n        n = n - m;\n    }\n    return q;\n}\n", "wrong_ans_explanation": "(a) \npublic static int remainder(int n, int m)\n{\n    int r = 0 ;\n    while (n > m)\n    {\n        n = n - m ;\n    }\n    r = n ;\n    return r;\n}\n\n(b) \npublic static int quotient (int n, int m)\n{\n    int q = 0;\n    for (q = 0; n > m; q++)\n    {\n        n = n - m;\n    }\n    return q;\n}\n",        "question": "Suppose that your version of Java does not have the division or modulo operator!\n\n(a) Complete the following method which returns the remainder when n is divided by m. Use repeated subtraction instead of the modulo operator.\n\npublic static int remainder(int n, int m)\n{\n    int r = 0;\n    \n    \n    \n    return r;\n}\n\n\n(b) Complete the following method which returns the quotient when n is divided by m. Use repeated subtraction instead of the division operator.\n\npublic static int quotient (int n, int m)\n{\n    int q = 0;\n\n\n\n    return q;\n}",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["\n Compare Your Answer \n\n"], "picture_or_video_name": ""}]}