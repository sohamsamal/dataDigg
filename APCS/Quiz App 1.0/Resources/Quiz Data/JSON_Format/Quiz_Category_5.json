{"Questions": [{"points": "1", "Answer": "2", "correct_ans_explanation": "All the options except for:\n\n\u201cwill run on any computer without modification\u201d\n\npertain to the enhancement and optimization of the algorithm of the program. However, the option shown above refers to a hardware issue that does not need to be addressed in a program for it to be considered robust. \n", "wrong_ans_explanation": "All the options except for:\n\n\u201cwill run on any computer without modification\u201d\n\npertain to the enhancement and optimization of the algorithm of the program. However, the option shown above refers to a hardware issue that does not need to be addressed in a program for it to be considered robust. \n", "question": "Which of the following is not necessarily a feature of a robust program?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n does not allow execution to proceed with invalid data\n\n", "\n uses algorithms that give correct answers for extreme data values\n\n", "\n will run on any computer without modification                                    \n\n", "\n will not allow division by zero\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "In order to adequately test this method using the smallest set of input values, you must have one input value to represent each scenario. For example, you would want to test the code for the scenarios where the shipping weights are less than 10 tons, between 10 and 25 tons, and greater than 25 tons. Therefore, we will use one input value for each scenario: 5, 15, and 30, respectively (there is no significant reason for choosing these specific numbers within their respective intervals). Additionally, shipping weights of 10 tons and 25 tons must be accounted for since they are different boundary scenarios of the scale given in the problem. However, the shipping weight of 0 tons does not need to be included in the smallest set of input values because one value under 10 tons has already been included and the resulting charge for 0 tons would simply be 0 dollars. Therefore, the smallest set of input values for shipping weights are:\n\n5, 10, 15, 25, 30\n", "wrong_ans_explanation": "In order to adequately test this method using the smallest set of input values, you must have one input value to represent each scenario. For example, you would want to test the code for the scenarios where the shipping weights are less than 10 tons, between 10 and 25 tons, and greater than 25 tons. Therefore, we will use one input value for each scenario: 5, 15, and 30, respectively (there is no significant reason for choosing these specific numbers within their respective intervals). Additionally, shipping weights of 10 tons and 25 tons must be accounted for since they are different boundary scenarios of the scale given in the problem. However, the shipping weight of 0 tons does not need to be included in the smallest set of input values because one value under 10 tons has already been included and the resulting charge for 0 tons would simply be 0 dollars. Therefore, the smallest set of input values for shipping weights are:\n\n5, 10, 15, 25, 30\n", "question": "A certain freight company charges its customers for shipping overseas according to this scale:\n\n    $80 per ton for a weight of 10 tons or less\n    $40 per ton for each additional ton over 10 tons but not exceeding 25 tons\n    $30 per ton for each additional ton over 25 tons\n\nFor example, to ship a weight of 12 tons will cost 10(80) + 2(40) = $880. To ship 26 tons will cost 10(80) + 15(40) + 1(30) = $1430.\nA method takes as parameter an integer that represents a valid shipping weight and outputs the charge for the shipment. Which of the following is the smallest set of input values for shipping weights that will adequately test this method?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 5, 15, 30\n\n", "\n 0, 5, 10, 15, 25, 30\n\n", "\n 5, 10, 15, 25, 30              \n\n", "\n 5, 10, 15, 20, 25, 30\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Since the number 4 is being cast to a double and the variables a, b, c, and d are all integers, an error would obviously be caused when the sum of these variables are divided by the double. This type casting error is known as a logic error because the computer cannot logically compute this equation with differing data types.\n", "wrong_ans_explanation": "Since the number 4 is being cast to a double and the variables a, b, c, and d are all integers, an error would obviously be caused when the sum of these variables are divided by the double. This type casting error is known as a logic error because the computer cannot logically compute this equation with differing data types.\n", "question": "A code segment calculates the mean of values in integers a, b, c, and d and stores the result in average, which is of type double. What kind of error is caused with this statement?\n\n    double average = a + b + c + d / (double) 4;\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n Logic        \n\n", "\n Run-time\n\n", "\n Overflow\n\n", "\n Syntax\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Since this problem of division by zero cannot be detected by the code, this oversight will not be detected at compile time or while editing the program. However, when the program begins to calculate the result of the expression, this problem will be detected and an error will occur. Therefore, during evaluation of the expressions, this oversight will be detected in the computer. \n", "wrong_ans_explanation": "Since this problem of division by zero cannot be detected by the code, this oversight will not be detected at compile time or while editing the program. However, when the program begins to calculate the result of the expression, this problem will be detected and an error will occur. Therefore, during evaluation of the expressions, this oversight will be detected in the computer. \n", "question": "A program evaluates binary arithmetic expressions that are read from an input file. All the operands are integers, and the only operators are +, -, *, and /. In writing the program, the programmer forgot to include a test that checks whether the right-hand operand in a division expression equals zero. When will this oversight be detected in the computer?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n At compile time\n\n", "\n While editing the program\n\n", "\n During evaluation of the expressions                   \n\n", "\n As soon as the data from the input file is read\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "The answer to this question is quite literally a textbook definition. The precondition a method describes what must be true when the method is called.\n", "wrong_ans_explanation": "The answer to this question is quite literally a textbook definition. The precondition a method describes what must be true when the method is called.\n", "question": "Which best describes the precondition of a method? It is an assertion that\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n initializes the parameters of the method.\n\n", "\n describes the effect of the method on its postcondition.\n\n", "\n states what the initial values of the local variables in the method must be.\n\n", "\n describes precisely the conditions that must be true at the time the method is called.           \n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "The answer to this problem can be solved with simple logic. In order to have the least amount of computer operations, the last if statement will not have to be executed. Hence, a or b must be the largest value to result in the least number of computer operations. On the other hand, c would have to be the largest value in order to have the greatest amount of computer operations because procedurally, if c was the largest value, every if statement will be executed in the code fragment.\n", "wrong_ans_explanation": "The answer to this problem can be solved with simple logic. In order to have the least amount of computer operations, the last if statement will not have to be executed. Hence, a or b must be the largest value to result in the least number of computer operations. On the other hand, c would have to be the largest value in order to have the greatest amount of computer operations because procedurally, if c was the largest value, every if statement will be executed in the code fragment.\n", "question": "Consider the following code fragment:\n\n    // Precondition: a, b, and c contain 3 distinct integers.\n    // Postcondition: max contains the largest of a, b, c.\n    //first set max equal to larger of a and b\n    if ( a > b )\n        max = a;\n    else \n        max = b;\n    // set max equal to larger of max and c\n    if ( max < c )\n        max = c;\n\nFor this algorithm, which of the following initial setups for a, b, and c will cause\n\n    (1) the least number of computer operations (best case) and\n    (2) the greatest number of computer operations (worst case)?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n (1) largest value in a or b\t\t(2) largest value in c           \n\n", "\n (1) smallest value in a or b\t\t(2) largest value in c\n\n", "\n (1) smallest value in a \t\t(2) largest value in b\n\n", "\n (1) largest value in b or c \t\t(2) largest value in a\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "This question requires you to understand what a precondition means concerning a specific code fragment or loop. In this case, the precondition for the while loop is the values of the variables needed for the while loop at the time when the loop is executed. Therefore, N >= 1 (as seen in the comments), j = 1 (as seen in the variable initialization), and sum = 1.0 (also seen in variable initialization). \n", "wrong_ans_explanation": "This question requires you to understand what a precondition means concerning a specific code fragment or loop. In this case, the precondition for the while loop is the values of the variables needed for the while loop at the time when the loop is executed. Therefore, N >= 1 (as seen in the comments), j = 1 (as seen in the variable initialization), and sum = 1.0 (also seen in variable initialization). \n", "question": "Refer to the following code segment.\n\n    //Compute the mean of integers 1 .. N.\n    // N is an integer >= 1 and has been initialized.\n    int j = 1;\n    double avg, sum = 1.0;\n    while (j < N)\n    {\n        /* loop body */\n    }\n    avg = sum / N;\n\nWhat is the precondition for the while loop?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n j < N, sum = 1.0\n\n", "\n j >= N, sum = 1.0\n\n", "\n avg = sum / N \n\n", "\n N >= 1, j = 1, sum = 1.0         \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "All that\u2019s needed to answer this question is your understanding of a for loop initialization in Java. In this method, j is initialized to be 3, iterates by 1 every loop,, and ends when j is equal to k. Therefore, 3 <= j <= k.\n", "wrong_ans_explanation": "All that\u2019s needed to answer this question is your understanding of a for loop initialization in Java. In this method, j is initialized to be 3, iterates by 1 every loop,, and ends when j is equal to k. Therefore, 3 <= j <= k.\n", "question": "The sequence of Fibonacci numbers is 1, 1, 2, 3, 5, 8, 13, 21, \u2026. The first two Fibonacci numbers are each 1. Each subsequent number is obtained by adding the previous two. Consider this method:  \n\n    // Precondition: n >= 1.\n    // Postcondition: The nth Fibonacci number has been returned.\n    public static int fibonacci(int k)\n    {\n        int prev = 1, next = 1, sum = 1;\n        for (int j = 3; j <= k; j++)\n        {\n            /* assertion */\n            sum = next + prev;\n            prev = next;\n            next = sum;\n        }\n        return sum;\n    }\n\nWhich of the following is a correct /* assertion */ about the loop variable j?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 0 <= j <= k\n\n", "\n 1 <= j <= k\n\n", "\n 3 <= j <= k                  \n\n", "\n 3 < j <= k\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Once you see the pattern, this question is fairly easy. The while loop in the mystery method iterates a number of b - c + 1 times (you can find this by testing different examples of b and c with real values). Every time the while loop runs, a is added to the total. Therefore, after the execution of mystery, total is equal to a * (b - c + 1). Since c = 1, total = a * b.\n", "wrong_ans_explanation": "Once you see the pattern, this question is fairly easy. The while loop in the mystery method iterates a number of b - c + 1 times (you can find this by testing different examples of b and c with real values). Every time the while loop runs, a is added to the total. Therefore, after the execution of mystery, total is equal to a * (b - c + 1). Since c = 1, total = a * b.\n", "question": "Refer to the following method.\n\n    //Precondition: a and b are initialized integers.\n    public static int mystery( int a, int b ) \n    {\n        int total = 0, c = 1;\n        while ( c <= b )\n        {\n            total += a;\n            c++;\n        }\n        return total;\n    }\n\nWhat is the postcondition for method mystery?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n total = a^b\n\n", "\n total = b^a\n\n", "\n total = a / b;\n\n", "\n total = a * b;          \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "In order for the class to be a reasonable choice to be responsible for the amountDue method, that class must have the proper information required for running this method. This information includes the quantity, unit price, and the total price for each item. Since the Item class is only limited to each item at a time, it is not suited for calculating the total amount of all the items. On the other hand, the ItemList and Invoice class are much more general than the Item class and contain the proper preconditions for executing the amountDue method. Therefore, only II and III are correct.\n", "wrong_ans_explanation": "In order for the class to be a reasonable choice to be responsible for the amountDue method, that class must have the proper information required for running this method. This information includes the quantity, unit price, and the total price for each item. Since the Item class is only limited to each item at a time, it is not suited for calculating the total amount of all the items. On the other hand, the ItemList and Invoice class are much more general than the Item class and contain the proper preconditions for executing the amountDue method. Therefore, only II and III are correct.\n", "question": "A program is to be written that prints an invoice for a small store. A copy of the invoice will be given to the customer and will display \n\n    A list of items purchased.\n    The quantity, unit price, and the total price for each item.\n    The amount due.\n\nThree candidate classes for this program are Invoice, Item, and ItemList, where an Item is a single item purchased. Which class \tis a reasonable choice to be responsible for the amountDue method, which returns the amount the customer must pay?\n\n    I \tItem\n    II \tItemList\n    III \tInvoice\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n III only\n\n", "\n I and II only\n\n", "\n II and III only       \n\n", "\n I, II, and III\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Remember that the is-a relationship in Java is indicative of inheritance, and the has-a relationship is indicative of composition. Suppose A is a Car Class and b is a Vehicle class. This means that A is-a B because the Car class should inherit from the Vehicle class (Car is a type of vehicle). However, in this case, B has-a A is false. Simply thinking logically, a Vehicle does not HAVE a Car. Rather, the Vehicle class is a parent class to the Car class. Therefore, the choice concerning is-a and has-a relationships is false. \n", "wrong_ans_explanation": "Remember that the is-a relationship in Java is indicative of inheritance, and the has-a relationship is indicative of composition. Suppose A is a Car Class and b is a Vehicle class. This means that A is-a B because the Car class should inherit from the Vehicle class (Car is a type of vehicle). However, in this case, B has-a A is false. Simply thinking logically, a Vehicle does not HAVE a Car. Rather, the Vehicle class is a parent class to the Car class. Therefore, the choice concerning is-a and has-a relationships is false. \n", "question": "Which is a false statement about classes in object-oriented program design?                                      \n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n If class A is independent, then none of its methods will have parameters that are objects of other classes.\n\n", "\n If class A has an instance variable whose type is another class, B, then A has-a B.\n\n", "\n If classes A and B are related such that A is-a B, then B has-a A.           \n\n", "\n If a class A is associated with another class, B, then A depends on B for its implementation.\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "In order for one class to properly inherit from another class, that class must be a type of the class its inheriting from. In other words, they must have an is-a relationship. The choice where Tire extends Circle does not follow this logic because although the Tire class will most likely use the Circle class as a property, a Tire is not a type of Circle, and therefore there is no need to inherit from it.\n", "wrong_ans_explanation": "In order for one class to properly inherit from another class, that class must be a type of the class its inheriting from. In other words, they must have an is-a relationship. The choice where Tire extends Circle does not follow this logic because although the Tire class will most likely use the Circle class as a property, a Tire is not a type of Circle, and therefore there is no need to inherit from it.\n", "question": "A Java program maintains a large database of vehicles and parts for a car dealership. Some of the classes in the program are Vehicle, Car, Truck, Tire, Circle, Steering Wheel, and AirBag. The declarations below show the relationships between classes. Which is a poor choice?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n \tpublic class Vehicle\n    {\t\u2026\n        private Tire[] tires;\n        private SteeringWheel sw;\n        \u2026\n    }\n\n", "\n \tpublic class Tire extends Circle          \n    {\t\u2026\n        // inherits methods that compute circumference and center point\n    }\n\n", "\n \tpublic class Car extends Vehicle\n    {\t\u2026\n        // inherits private Tire[] tires from Vehicle class\n        // inherits private SteeringWheel sw from Vehicle class\n        \u2026\n    }\n\n", "\n \tpublic class Tire\n    {\t\u2026\n        private String rating;          // speed rating of tire\n        private Circle boundary;\n    }\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "This question is a bit obscure and most likely will not show up on the AP. However, this concept is useful when creating your own large programs and projects as a programmer. When starting a coding project, it is hard to know where to start first and how to connect differing aspects of your code to each other. Firstly, you must take care of independent classes because they do not need references from other classes. Then, classes that will be used to implement other classes should be made. Afterwards, superclasses and then subclasses must be made because they have the most references to other classes. \n", "wrong_ans_explanation": "This question is a bit obscure and most likely will not show up on the AP. However, this concept is useful when creating your own large programs and projects as a programmer. When starting a coding project, it is hard to know where to start first and how to connect differing aspects of your code to each other. Firstly, you must take care of independent classes because they do not need references from other classes. Then, classes that will be used to implement other classes should be made. Afterwards, superclasses and then subclasses must be made because they have the most references to other classes. \n", "question": "A Java programmer has completed a preliminary design for a large program. The programmer has developed a list of classes, determined the methods for each class, established the relationships between classes, and written an outline for each class. Which class(es) should be implemented first?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n Any superclasses\n\n", "\n Any subclasses\n\n", "\n All collaborator classes (classes that will be used to implement other classes)\n\n", "\n All independent classes (classes that have no references to other classes)       \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Option I would obviously contain 4 elements each with value 0 because it is already explicitly initialized as so. Option II would also contain 4 elements each with value 0 because when arrays are initialized with a set length, all elements within the array are set to 0 by default. Finally, option III would also contain 4 elements with value 0 because it iterates over the array and sets each value to 0.\n", "wrong_ans_explanation": "Option I would obviously contain 4 elements each with value 0 because it is already explicitly initialized as so. Option II would also contain 4 elements each with value 0 because when arrays are initialized with a set length, all elements within the array are set to 0 by default. Finally, option III would also contain 4 elements with value 0 because it iterates over the array and sets each value to 0.\n", "question": "Which of the following correctly initializes an array a to contain four elements each with value 0?                            \n\n    I. int[] a = {0, 0, 0, 0};\n    II. int[] a = new int[4];\n    III. int[] a = new int[4];\n         for (int k = 0; k < a.length; k++)\n                a[k] = 0;\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n III only\n\n", "\n I and III only\n\n", "\n II and III only\n\n", "\n I, II, and III        \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "You may think that the program segment will always work as intended. However, if a does not contain any negative integers, j will keep increasing until an IndexOutOfBounds Exception arises due to the while loop. Therefore, in order for the segment to work as intended, a must contain at least one negative integer.\n", "wrong_ans_explanation": "You may think that the program segment will always work as intended. However, if a does not contain any negative integers, j will keep increasing until an IndexOutOfBounds Exception arises due to the while loop. Therefore, in order for the segment to work as intended, a must contain at least one negative integer.\n", "question": "The following program segment is intended to find the index of the first negative integer in a[0] \u2026 a[N - 1], where a is an array of integers.\t\n\n    int j = 0;\n    while (a[j] >= 0)\n    {\n        j++;\n    }\n    loc = j;\n\nThis segment will work as intended\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n always\n\n", "\n never\n\n", "\n whenever a contains at least one negative integer.                \n\n", "\n whenever a contains at least one nonnegative integer.\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "For this problem, it would be easy to take an example and then see what happens. Suppose a.length = 1. This means that the while loop will only execute once. In this one loop, k will equal one and a[1] will be added to the sum. However, since a only contains one element, a[1] would not exist, causing a run-time error to occur.\n", "wrong_ans_explanation": "For this problem, it would be easy to take an example and then see what happens. Suppose a.length = 1. This means that the while loop will only execute once. In this one loop, k will equal one and a[1] will be added to the sum. However, since a only contains one element, a[1] would not exist, causing a run-time error to occur.\n", "question": "Refer to the following code segment. You may assume that a is an array of int values.\n\n    int sum = a[0], k = 0;\n    while (k < a.length)\n    {\n        k++;\n        sum += a[k] ;\n    }\n\nWhich of the following will be the result of executing the segment?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n sum of a[0], a[1], \u2026, a[a.length - 1] will be stored in sum.\n\n", "\n sum of a[0], a[1], \u2026, a[a.length] will be stored in sum.\n\n", "\n An infinite loop will occur.\t\n\n", "\n A run-time error will occur.            \n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "There are two ways to reach the solution for this problem. One way would be to take the example and manually run through each iteration of the for loop until it stops executing. However, since you are under a heavy time constraint on the AP, it would not be the wisest choice. The more time-efficient solution would be to understand the function of the code, and then apply it to the example. As we can see, a[c] is only being set to a[j] whenever a[j] is not equal to 0. Whenever a[j] != 0, a[c] is set to a[j] and then c increases. Since c begins from 0, we know that values are being changed from the beginning of the array. We also know that these values are being set to corresponding values in the array that are not equal to 0. Therefore, after the code executes, b = [6, 4, 2].\n", "wrong_ans_explanation": "There are two ways to reach the solution for this problem. One way would be to take the example and manually run through each iteration of the for loop until it stops executing. However, since you are under a heavy time constraint on the AP, it would not be the wisest choice. The more time-efficient solution would be to understand the function of the code, and then apply it to the example. As we can see, a[c] is only being set to a[j] whenever a[j] is not equal to 0. Whenever a[j] != 0, a[c] is set to a[j] and then c increases. Since c begins from 0, we know that values are being changed from the beginning of the array. We also know that these values are being set to corresponding values in the array that are not equal to 0. Therefore, after the code executes, b = [6, 4, 2].\n", "question": "Refer to the following code segment. You may assume that array a contains elements a[0], a[1], \u2026, a[N - 1], where N = a.length.\n\n    int c = 0;\n    for (int j = 0; j < N; j++)\n        if (a[j] != 0)\n        {\n            a[c] = a[j];\n            c++;\n        }\n    int[] b = new int[c];\n    for (int j = 0; j < c; j++)\n        b[j] = a[j];\n\nIf array a initially contains the elements 0, 6, 0, 4, 0, 0, 2 in this order, what will b contain after execution of the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 6, 4, 2\t\t\t\t\n\n", "\n 0, 0, 0, 0, 6, 4, 2\t\n\n", "\n 6, 4, 2, 4, 0, 0, 2\n\n", "\n 0, 6, 0, 4, 0, 0, 2\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Suppose k = 3. The maximum amount of times that SMALL will be printed would be 2, considering that the if statement is true at all times. Furthermore, if k = 4, the maximum amount of times that SMALL would be printed is 3. Considering this pattern, we can express the maximum number of times that SMALL will be printed as k - 1.\n", "wrong_ans_explanation": "Suppose k = 3. The maximum amount of times that SMALL will be printed would be 2, considering that the if statement is true at all times. Furthermore, if k = 4, the maximum amount of times that SMALL would be printed is 3. Considering this pattern, we can express the maximum number of times that SMALL will be printed as k - 1.\n", "question": "Consider this program segment:\n\n    for (int j = 2; j <= k; j++)\n        if (a[j] < someVal)\n            System.out.print(\u201cSMALL\u201d);\n\nWhat is the maximum number of times that SMALL be printed?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 1\n\n", "\n k - 2\n\n", "\n k - 1              \n\n", "\n k\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "One very important functionality that ArrayLists have, but arrays don\u2019t, is their ability to automatically increase capacity or resize. Unlike arrays, when elements are added to an ArrayList, its capacity grows automatically. This is important for the example of text files because it would be time consuming to figure out the amount of lines in each text file and then change the size of the array accordingly. With ArrayLists, this problem will vanish because of their ability to resize.\n", "wrong_ans_explanation": "One very important functionality that ArrayLists have, but arrays don\u2019t, is their ability to automatically increase capacity or resize. Unlike arrays, when elements are added to an ArrayList, its capacity grows automatically. This is important for the example of text files because it would be time consuming to figure out the amount of lines in each text file and then change the size of the array accordingly. With ArrayLists, this problem will vanish because of their ability to resize.\n", "question": "Consider writing a program that reads the lines any text file into a sequential list of lines. Which of the following is a good reason to implement the list with an ArrayList of String objects rather than an array of String objects?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n The get and set methods of ArrayList are more convenient than the [] notation for arrays.\n\n", "\n The size method of ArrayList provides instant access to the length of the list.\n\n", "\n If any particular text file is unexpectedly long, the ArrayList will automatically be resized. The array, by contrast, may go out of bounds.                \n\n", "\n None of the choices\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Insertion, removal, and accessing of elements is most likely easier to perform in ArrayLists than arrays (or at least they require the same amount of effort). However, the main problem in this case is the massive amount of wrapper objects that would need to be unwrapped if you were to use ArrayLists. This would require much more computing power and would take more time. Therefore, it would be better to implement each list with an array of ints or doubles (primitive data types). \n", "wrong_ans_explanation": "Insertion, removal, and accessing of elements is most likely easier to perform in ArrayLists than arrays (or at least they require the same amount of effort). However, the main problem in this case is the massive amount of wrapper objects that would need to be unwrapped if you were to use ArrayLists. This would require much more computing power and would take more time. Therefore, it would be better to implement each list with an array of ints or doubles (primitive data types). \n", "question": "Consider writing a program that produces statistics for long lists of numerical data. Which of the following is the best reason to implement each list with an array of int (or double), rather than an ArrayList of Integer (or Double) objects? \n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n An array of primitive number types is more efficient to manipulate than an ArrayList of wrapper objects that contain numbers.         \n\n\n", "\n Insertion of new elements into a list is easier to code for an array than for an ArrayList.\n\n", "\n Removal of elements from a list is easier to code for an array than for an ArrayList.\n\n", "\n Accessing individual elements in the middle of a list is easier for an array than for an ArrayList.\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "Option I will not cause an error because the declaration properly instantiates a List Object of Strings. Option III will also not cause an error because ArrayLists are a subtype of the List interface, and therefore can be instantiated the same way as Lists. However, option II will cause an error because when instantiating a List or ArrayList of primitive types, a wrapper object must be used. In this case, the wrapper object Integer must be used or else an error would occur.\n", "wrong_ans_explanation": "Option I will not cause an error because the declaration properly instantiates a List Object of Strings. Option III will also not cause an error because ArrayLists are a subtype of the List interface, and therefore can be instantiated the same way as Lists. However, option II will cause an error because when instantiating a List or ArrayList of primitive types, a wrapper object must be used. In this case, the wrapper object Integer must be used or else an error would occur.\n", "question": "Which declaration will cause an error?\n\n    I. List<String> strList = new ArrayList<String>();\n    II. List<int> intList = new ArrayList<int>();\n    III. ArrayList<String> compList = new ArrayList<String>();\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n I only\n\n", "\n II only       \n\n", "\n III only\n\n", "\n II and III only\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "strList.add(c) will not cause an error because strList is defined as a list of String objects, and c is a String. strList.add(o.toString()) will also not cause an error because the toString() method converts o into a String. strList.add(c + 8) will not cause an error because string concatenation will occur and the 8 will automatically be converted to a string. However, strList.add(o + 8) will cause an error because an Integer cannot be added to a List of Strings.\n", "wrong_ans_explanation": "strList.add(c) will not cause an error because strList is defined as a list of String objects, and c is a String. strList.add(o.toString()) will also not cause an error because the toString() method converts o into a String. strList.add(c + 8) will not cause an error because string concatenation will occur and the 8 will automatically be converted to a string. However, strList.add(o + 8) will cause an error because an Integer cannot be added to a List of Strings.\n", "question": "Consider these declarations:\n\n    List<String> strList = new ArrayList<String>();\n    String c = \u201c \u201c;\n    Integer o = new Integer(5);\n\nWhich statement will cause an error?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n strList.add( c );\n\n", "\n strList.add(o.toString());\n\n", "\n strList.add(c + 8);\n\n", "\n strList.add(o + 8);              \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "For most of the choices, an object is attempting to be instantiated while altering or accessing some part of the ArrayList. This will definitely cause an error because an object cannot be instantiated while simultaneously setting it to a functionality. The only option that would not cause an error is list.add(6, 9) because it is only adding the element 9 to the index 6.\n", "wrong_ans_explanation": "For most of the choices, an object is attempting to be instantiated while altering or accessing some part of the ArrayList. This will definitely cause an error because an object cannot be instantiated while simultaneously setting it to a functionality. The only option that would not cause an error is list.add(6, 9) because it is only adding the element 9 to the index 6.\n", "question": "Let list be an ArrayList<Integer> containing these elements:\n\n    2 5 7 6 0 1\n\nWhich of the following statements would not cause an error to occur? Assume that each statement applies to the given list, independent of the other statements.\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n Object o = list.get(6);\n\n", "\n Object x = list.remove(6);\n\n", "\n list.add(6, 9);                         \n\n", "\n Object y = list.set(6, 8);\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "Since the list contains 3 elements, there will be 3 iterations of the for loop. In the first iteration, j = 0 and 0 is being added to the first index. Additionally, the 0th index is being set to 2. Therefore, after the first iteration, list would be:\n\n2 0 1 8\n\nIn the second iteration, 1 is added to the 2nd index and 3 is being set to the 1st index. After the second iteration, list would be:\n\n2 3 1 1 8\n\nIn the third iteration, 2 is being added to the 3rd index and 4 is being set to the 2nd index. Therefore, after executing the code segment, list would be:\n\n2 3 4 2 1 8\n", "wrong_ans_explanation": "Since the list contains 3 elements, there will be 3 iterations of the for loop. In the first iteration, j = 0 and 0 is being added to the first index. Additionally, the 0th index is being set to 2. Therefore, after the first iteration, list would be:\n\n2 0 1 8\n\nIn the second iteration, 1 is added to the 2nd index and 3 is being set to the 1st index. After the second iteration, list would be:\n\n2 3 1 1 8\n\nIn the third iteration, 2 is being added to the 3rd index and 4 is being set to the 2nd index. Therefore, after executing the code segment, list would be:\n\n2 3 4 2 1 8\n", "question": "Consider the following code segment, applied to list, an ArrayList of Integer of values.\n\n    int len = list.size();\n    for (int j = 0; j < len; j++)\n    {\n        list.add(j + 1, new Integer(j));\n        Object x = list.set(j, new Integer(j + 2));\n    }\n\nIf list is initially 6 1 8 , what will be following execution of the code segment?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 2 3 4 2 1 8       \n\n", "\n 2 3 4 0 1 2\n\n", "\n 2 3 4 6 1 8\n\n", "\n 2 3 4 6 2 2 0 1 8\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Recursive algorithm is an algorthim which calls itself with smaller or simpler input values. Therefore, I and III are the basic definition of recursive algorithm. Moreover, \u201cdivide-and conquer\u201d algorithm is based on recursively breaking down the problem into smaller/simpler problems. Hence, II is also true.  \n", "wrong_ans_explanation": "Recursive algorithm is an algorthim which calls itself with smaller or simpler input values. Therefore, I and III are the basic definition of recursive algorithm. Moreover, \u201cdivide-and conquer\u201d algorithm is based on recursively breaking down the problem into smaller/simpler problems. Hence, II is also true.  \n", "question": "Which of the following statements about recursion are true?                                                       \n\n    I. Every recursive algorithm can be written iteratively.\n    II. Tail recursion is always used in \u201cdivide-and-conquer\u201d algorithms.\n    III. In a recursive definition, a process is defined in terms of a simpler case of itself.\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only\n\n", "\n I and III only       \n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "Option I would not perform its desired task because the method would keep adding n - 1 to n infinitely, causing an infinite loop to occur. Option III would also not work because although the if-else statement is the right way to begin, sum(n) in the else statement would cause an infinite recursion (n is never decreasing). Finally, option II would work because n is recursively being added to n - 1 until n = 1, at which point 1 is returned and the sum is calculated.\n", "wrong_ans_explanation": "Option I would not perform its desired task because the method would keep adding n - 1 to n infinitely, causing an infinite loop to occur. Option III would also not work because although the if-else statement is the right way to begin, sum(n) in the else statement would cause an infinite recursion (n is never decreasing). Finally, option II would work because n is recursively being added to n - 1 until n = 1, at which point 1 is returned and the sum is calculated.\n", "question": "Which of the following, when used as the /* body */ of method add, will enable that method to compute 1 + 2 + \u2026 + n correctly for any n > 0?\n\n    // param n a positive integer\n    // return 1 + 2 + \u2026 + n\n    public int add(int n)\n    {\n        /* body */\n    }\n\n    I. \treturn n + add(n - 1);\n    II. \tif (n == 1)\n            return 1;\n        else\n            return n + sum(n - 1);\n    III. \tif (n == 1)\n            return 1;\n        else\n            return sum(n) + sum(n - 1);\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n I only\n\n", "\n II only          \n\n", "\n III only\n\n", "\n I and II only \n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "This method will never terminate without error because although s is printed when s.length() < 15, the method never returns anything, and therefore, the method continues to recur until there is an infinite loop.\n", "wrong_ans_explanation": "This method will never terminate without error because although s is printed when s.length() < 15, the method never returns anything, and therefore, the method continues to recur until there is an infinite loop.\n", "question": "Refer to the method recur:\n\n    public void recur(String s)\n    {\n        if (s.length() < 15)\n            System.out.println(s);\n        recur(s + \u201c*\u201d);\n    }\n\nWhen will method recur terminate without error?\t\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n Only when an empty string is input\n\n", "\n Only when the length of the string is less than 15\n\n", "\n For all string inputs\n\n", "\n For no string inputs             \n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "This method will always terminate without error because the length of s only increases and recursion only occurs when s.length() < 15. If s.length() is initially over 15, no error would occur because recursion will not occur. If s.length() is initially under 15, then s.length() will keep increasing until s.length() = 15, at which point the method will terminate without error. \n", "wrong_ans_explanation": "This method will always terminate without error because the length of s only increases and recursion only occurs when s.length() < 15. If s.length() is initially over 15, no error would occur because recursion will not occur. If s.length() is initially under 15, then s.length() will keep increasing until s.length() = 15, at which point the method will terminate without error. \n", "question": "Refer to the method recur:\n\n    public void recur(String s)\n    {\n        if (s.length() < 15)\n        {\n            System.out.println(s);\n            recur(s + \u201c*\u201d);\n        }\n    }\n\nWhen will method recur terminate without error?\t\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n Only when an empty string is input\n\n", "\n Only when the length of the string is less than 15\n\n", "\n For all string inputs\t\t\n\n", "\n For no string inputs            \n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "The pattern for this recursive method is pretty simple. Every time k is decreased by 1, 2 is multiplied by it until k == 1. Following this pattern, it can be seen that the method returns 2^k. In other words, 2 is multiplied by itself k times. Therefore, when k is 5, mystery returns 2^5 = 32.\n", "wrong_ans_explanation": "The pattern for this recursive method is pretty simple. Every time k is decreased by 1, 2 is multiplied by it until k == 1. Following this pattern, it can be seen that the method returns 2^k. In other words, 2 is multiplied by itself k times. Therefore, when k is 5, mystery returns 2^5 = 32.\n", "question": "Refer to the method mystery:\n\n    public int mystery(int k)\n    {\n        if (k == 1)\n            return 2;\n        else\n            return 2 * result(k - 1);\n    }\n\nWhat value does result(5) return?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 64\n\n", "\n 32           \n\n", "\n 16\n\n", "\n 8\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "Let us take k as 2. Since k != 1, the else statement will be called, and 2 * mystery(1) will be returned. Since mystery(1) = 1, 2 will be returned. Including the initial call, mystery was called twice. Therefore, mystery is called k times.\n", "wrong_ans_explanation": "Let us take k as 2. Since k != 1, the else statement will be called, and 2 * mystery(1) will be returned. Since mystery(1) = 1, 2 will be returned. Including the initial call, mystery was called twice. Therefore, mystery is called k times.\n", "question": "Refer to the method mystery:\n\n    public int mystery(int k)\n    {\n        if (k == 1)\n            return 2;\n        else\n            return 2 * result(k - 1);\n    }\n\nIf k > 0, how many times will mystery be called to evaluate mystery(k) (including the initial call)?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 2k\n\n", "\n 2\n\n", "\n k          \n\n", "\n 2^n\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "In this recursive method, a is the variable that is decreasing after every recursion. Since a is 3, the else statement will be called twice and the if statement will be called once. Keeping this in mind, mystery will return c + c + b = 14.\n\nRationale: The mystery method must be called to everything in order form least to greatest. Additionally, in order to procure the highest value number from the group\n", "wrong_ans_explanation": "In this recursive method, a is the variable that is decreasing after every recursion. Since a is 3, the else statement will be called twice and the if statement will be called once. Keeping this in mind, mystery will return c + c + b = 14.\n\nRationale: The mystery method must be called to everything in order form least to greatest. Additionally, in order to procure the highest value number from the group\n", "question": "Refer to the method mystery:\n\n    public int mystery( int a, int b, int c )\n    {\n        if (a == 1)\n            return b;\n        else\n            return c + mystery( a - 1, b, c );\n    }\n\nWhat value is returned by the call mystery(3, 2, 6)?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 20\n\n", "\n 14             \n\n", "\n 10\n\n", "\n 8\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "As can be seen, the method terminates when b = a. Essentially, the larger of b and a is subtracted by the other recursively until b and a are equal. Firstly, since b > a, something(6, 8) results in something(6, 2). This, in turn, results in something(4, 2) and finally something(2, 2). Therefore, 2 is returned.\n", "wrong_ans_explanation": "As can be seen, the method terminates when b = a. Essentially, the larger of b and a is subtracted by the other recursively until b and a are equal. Firstly, since b > a, something(6, 8) results in something(6, 2). This, in turn, results in something(4, 2) and finally something(2, 2). Therefore, 2 is returned.\n", "question": "Refer to the method something:\n\n    public int something(int e, int f)\n    {\n        if (f == e)\n            return e;\n        else\n            if (f > e)\n                return something(e, f - e);\n            else\n                return something(e - f, f);\n    }\n\nWhat value is returned by the call something(6, 8)?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 8\n\n", "\n 4\n\n", "\n 3\n\n", "\n 2          \n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "As can be seen, every time print is called, the parameter becomes one shorter, omitting its first character. This eventually results in many calls of the print method, all bundled within each other. The most bundled print call\u2019s parameter is the last character of the original string s. Since s.substring(0, 1) is printed after every call of print(s), when the print methods start unwrapping, the string will be printed starting from the last character, resulting in the reverse order of the string s.\n", "wrong_ans_explanation": "As can be seen, every time print is called, the parameter becomes one shorter, omitting its first character. This eventually results in many calls of the print method, all bundled within each other. The most bundled print call\u2019s parameter is the last character of the original string s. Since s.substring(0, 1) is printed after every call of print(s), when the print methods start unwrapping, the string will be printed starting from the last character, resulting in the reverse order of the string s.\n", "question": "Which best describes what the print method below does?\n\n    public void print(String s)\n    {\n        if (s.length() > 0)\n        {\n            print(s.substring(1));\n            Sytem.out.print(s.substring(0, 1));\n        }\n    }\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n It prints string s.\n\n", "\n It prints string s in reverse order.         \n\n", "\n It prints only the first character of the string s.\n\n", "\n It prints only the last character of the string s.\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "If n = 6, as seen in the last question, then n = 6 at // Point A. Furthermore, if n = 2, then at // Point C, x would be equal to 1. Additionally, at // Point C, since the while loop regulates the value of n, n can never be greater than 2 at // Point C. Moreover, since the while loop controls the value of n above 2, the correct answer is:\n        \n    n will always be greater than 2 at // Point B \n        ", "wrong_ans_explanation": "If n = 6, as seen in the last question, then n = 6 at // Point A. Furthermore, if n = 2, then at // Point C, x would be equal to 1. Additionally, at // Point C, since the while loop regulates the value of n, n can never be greater than 2 at // Point C. Moreover, since the while loop controls the value of n above 2, the correct answer is:\n        \n    n will always be greater than 2 at // Point B \n        ", "question": "Consider the following method.\n                        \n    public static int mystery(int n)\n    {\n        int x = 1;        \n        int y = 1;\n        // Point A\n        while (n > 2)\n        {\n            x = x + y;\n            // Point B        \n            y = x - y;\n            n--;        \n        }\n        // Point C\n        return x;\n    }\n        \nWhich of the following is true of the method mystery?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n n will always be greater than 2 at // Point B.           \n\n", "\n n will never be greater than 2 at // Point A.\n\n", "\n x will never be 1 at // Point C.\n\n", "\n n will sometimes be greater than 2 at // Point C.\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "In order to use the compareTo method without a compiler error, the class should have a compareTo method defined, which has not been done here. \n\nThe other statement: \n\n    The test if (d1.equals(d2)) will cause a compile-time error \n\nis false because every class inherits the equals method from the universal superclass Object. \n\nFor the statement:\n\n    The test if (d1.equals(d2)) will return true,\n\nthe test will return true only if the equals method is overridden in class Date in such a way that two Date objects are equal if their month, day, and year data fields are equal. Since we don't know whether equals has been overridden, you can't state that this choice is true. \n\nFor the statement,\n\n    The test if (d1.compareTo(d2) == 0) will be true,\n\nthe test can't be true if it doesn't compile.\n", "wrong_ans_explanation": "In order to use the compareTo method without a compiler error, the class should have a compareTo method defined, which has not been done here. \n\nThe other statement: \n\n    The test if (d1.equals(d2)) will cause a compile-time error \n\nis false because every class inherits the equals method from the universal superclass Object. \n\nFor the statement:\n\n    The test if (d1.equals(d2)) will return true,\n\nthe test will return true only if the equals method is overridden in class Date in such a way that two Date objects are equal if their month, day, and year data fields are equal. Since we don't know whether equals has been overridden, you can't state that this choice is true. \n\nFor the statement,\n\n    The test if (d1.compareTo(d2) == 0) will be true,\n\nthe test can't be true if it doesn't compile.\n", "question": "Consider a Date class whose partial representation is shown below:  \n\n    public class Date\n    {\n        private int month, day, year;\n\n        //Constructor\n        public Date(int aMonth, int aDay, int aYear)\n        {\n            month = aMonth;\n            day = aDay;\n            year = aYear;\n        }\n\n        //Other methods and constructors not shown.\n        //There is no compareTo method in the class.\n    }\n\nConsider the following declarations:\n\n    Date d1 = new Date(2, 17, 1948);\n    Date d2 = new Date(2, 17, 1948);\n\nBased on the given information, which of the following statements must be true?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n The test if (d1.equals(d2)) will cause a compile-time error\n\n", "\n The test If (d1.equals(d2)) will return true\n\n", "\n The test if (d1.compareTo(d2) == 0) will be true\n\n", "\n The test if (d1.compareTo(d2) == 0) will cause a compile-time error\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "Here are the elements that are added to total:\n\nr = 0:  mat[0][0]        2\nr = 1:  mat[1][0] + mat[1][1]        4 + 5\nr = 2:  mat[2][0] + mat[2][1]  + mat[2][2]        7 + 1 + 2\nValue returned = 2 + 4 + 5 + 7 + 1 + 2 = 21\n", "wrong_ans_explanation": "Here are the elements that are added to total:\n\nr = 0:  mat[0][0]        2\nr = 1:  mat[1][0] + mat[1][1]        4 + 5\nr = 2:  mat[2][0] + mat[2][1]  + mat[2][2]        7 + 1 + 2\nValue returned = 2 + 4 + 5 + 7 + 1 + 2 = 21\n", "question": "A square matrix is declared as\n\n    int[][] mat = new int[SIZE][SIZE];\n\nwhere SIZE is an appropriate integer constant. Consider the following method:\n\n    public static void sum(int[][] mat)\n    {\n        int total = 0;\n        for (int r = 0; r < mat.length; r++)\n            for (int c = 0; c <= r; c++)\n                total += mat[r][c];\n        return total;\n    }\n\nIf mat is initialized to be\n\n    2  6  3\n    4  5  1\n    7  1  2\n\nwhat value will be returned by a call to sum(mat)?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n 9\n\n", "\n 15\n\n", "\n 19\n\n", "\n 21\n\n"]}, {"points": "1", "Answer": "1", "correct_ans_explanation": "The superclass, Dancer, does not have a default constructor; therefore, segment I is incorrect. Segment II works because the constructor for Dancer has one String parameter. Segment III fails because a subclass cannot directly access the private data of its superclasses.\n", "wrong_ans_explanation": "The superclass, Dancer, does not have a default constructor; therefore, segment I is incorrect. Segment II works because the constructor for Dancer has one String parameter. Segment III fails because a subclass cannot directly access the private data of its superclasses.\n", "question": "Refer to the following classes:\n\n    public abstract class Performer\n    {\n        private String specialty;\n        \n        //constructor.\n        public Performer(String aSpecialty)\n        { specialty = aSpecialty; }\n\n        public abstract void doRoutine();\n\n        //...other methods not shown\n    }\n\n    public class Dancer extends Performer\n    {\n        //constructor.\n        public Dancer(String aSpecialty)\n        { /* implementation */ }\n\n        public void doRoutine()\n        { System.out.println(\"backflip and spin\"); }\n\n        //...other methods not shown\n    }\n\n    public class BalletDancer extends Performer\n    {\n        //constructor.\n        public BalletDancer(String aSpecialty)\n        { /* implementation */ }\n\n        public void doRoutine()\n        { System.out.println(\"pirouette\"); }\n\n        //...other methods not shown\n    }\n\nWhich is correct /* implementation */ code for the constructor of the BalletDancer class?\n\n      I. super();\n     II. super(aSpecialty);\n    III. specialty = aSpecialty;\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only\n\n", "\n II and III only\n\n"]}, {"points": "1", "Answer": "0", "correct_ans_explanation": "The code will work as intended; namely, at run time, the appropriate doRoutine method will be called, depending on the current instance of Performer p. This is an example of polymorphism or dynamic binding. Polymorphism occurs when a superclass method has been overridden in a subclass.\n", "wrong_ans_explanation": "The code will work as intended; namely, at run time, the appropriate doRoutine method will be called, depending on the current instance of Performer p. This is an example of polymorphism or dynamic binding. Polymorphism occurs when a superclass method has been overridden in a subclass.\n", "question": "Refer to the following classes:\n\n    public abstract class Performer\n    {\n        private String specialty;\n        \n        //constructor.\n        public Performer(String aSpecialty)\n        { specialty = aSpecialty; }\n\n        public abstract void doRoutine();\n\n        //...other methods not shown\n    }\n\n    public class Dancer extends Performer\n    {\n        //constructor.\n        public Dancer(String aSpecialty)\n        { /* implementation */ }\n\n        public void doRoutine()\n        { System.out.println(\"backflip and spin\"); }\n\n        //...other methods not shown\n    }\n\n    public class BalletDancer extends Performer\n    {\n        //constructor.\n        public BalletDancer(String aSpecialty)\n        { /* implementation */ }\n\n        public void doRoutine()\n        { System.out.println(\"pirouette\"); }\n\n        //...other methods not shown\n    }\n\nA client class has a List<Performer> performers that is initialized with many different objects that are subclasses of Performer. Each subclass has an overridden doRoutine method, similar to those shown in the Dancer and BalletDancer classes. What is the effect of executing the following code segment?\n\n    for (Performer p : performers)\n        p.doRoutine();\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n The unique routine for each particular Performer will be output.\n\n", "\n There will be a compile-time error with a message to the effect that doRoutine is abstract in class Performer.\n\n", "\n There will be a compile-time error with a message to the effect that Performer p needs to be cast to its actual type.\n\n", "\n A ClassCastException will be thrown.\n\n"]}, {"points": "1", "Answer": "3", "correct_ans_explanation": "All are correct, depending on whether SIZE is 4, 3, or 2. The method fills the two-dimensional square array strMat with single-character strings obtained with str.substring(i, i + 1) in row-major order -- the first row is filled from left to right, then the second row, and so on. When the test if (i < str.length()) fails, the remaining matrix slots are filled with zeroes, as in matrix I. Notice that if the number of slots in the matrix is less than the number of characters in str, the method will quit without error before the entire string is processed, which is what happened for matrix III.\n", "wrong_ans_explanation": "All are correct, depending on whether SIZE is 4, 3, or 2. The method fills the two-dimensional square array strMat with single-character strings obtained with str.substring(i, i + 1) in row-major order -- the first row is filled from left to right, then the second row, and so on. When the test if (i < str.length()) fails, the remaining matrix slots are filled with zeroes, as in matrix I. Notice that if the number of slots in the matrix is less than the number of characters in str, the method will quit without error before the entire string is processed, which is what happened for matrix III.\n", "question": "A class has a two-dimensional square array:\n\n    private String[][] strMat;\n\nThe array is initialized to have SIZE rows and columns. Consider the following method in the class.\n\n    private void fillArray(String str)\n    {\n        int i = 0;\n        for (int r = 0; r < SIZE; r++)\n        {\n            for (int c = 0; c < SIZE; c++)\n            {\n                if (i < str.length())\n                    strMat[r][c] = str.substring(i, i + 1);\n                else\n                    strMatrix[r][c] = \"0\";\n                i++;\n            }\n        }\n    }\n\nWhich of the following could be the resulting matrix after a call to fillArray(\"obtaining\"), assuming that the method runs without error?\n\n         I. o b t a\n            i n i n\n            g 0 0 0\n            0 0 0 0\n\n        II. o b t\n            a i n\n            i n g\n\n       III. o b\n            t a\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n I only\n\n", "\n II only\n\n", "\n III only\n\n", "\n I, II, and III\n\n"]}, {"points": "1", "Answer": "2", "correct_ans_explanation": "This statement will cause an IndexOutOfBoundsException because there is no slot with index 5. Note that this choice \n\n    Object ob = list.add(5, 7) \n\nis correct because the size of the list will be adjusted to 6, and the Integer 7 will be added to the last slot, i.e., the slot with index 5.\n", "wrong_ans_explanation": "This statement will cause an IndexOutOfBoundsException because there is no slot with index 5. Note that this choice \n\n    Object ob = list.add(5, 7) \n\nis correct because the size of the list will be adjusted to 6, and the Integer 7 will be added to the last slot, i.e., the slot with index 5.\n", "question": "Let list be an ArrayList<Integer> containing these elements:\n\n    4 5 6 2 1\n\nWhich of the following statements will cause an error?\n\n", "negative_points": "0", "duration_in_seconds": "135", "question_type": "1", "options": ["\n list.add(5);\n\n", "\n list.add(2, 4);\n\n", "\n Integer intOb = list.get(5);\n\n", "\n Object ob = list.add(5, 7);\n\n"]}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a)\nprivate String recombine (String word1, String word2)\n{\n    String s = word1.substring(0, word1.length()/2); \n    String t = word2.substring(word2.length()/2, word2.length()); \n    return s + t;\n}\n\n(b) \nprivate String[] mixedWords(String[] words)\n{\n    String q = \"\";\n    String p = \"\";\n    String[] s = new String[words.length];\n    for (int i = 0; i < words.length - 1; i += 2)\n    {\n        s[i] = recombine(words[i], words[i + 1]);\n        s[i + 1] = recombine(words[i + 1], words[i]); \n    }\n    return s;\n}\n", "wrong_ans_explanation": "(a)\nprivate String recombine (String word1, String word2)\n{\n    String s = word1.substring(0, word1.length()/2); \n    String t = word2.substring(word2.length()/2, word2.length()); \n    return s + t;\n}\n\n(b) \nprivate String[] mixedWords(String[] words)\n{\n    String q = \"\";\n    String p = \"\";\n    String[] s = new String[words.length];\n    for (int i = 0; i < words.length - 1; i += 2)\n    {\n        s[i] = recombine(words[i], words[i + 1]);\n        s[i + 1] = recombine(words[i + 1], words[i]); \n    }\n    return s;\n}\n",        "question": "Consider the following partial declaration for a WordScrambler class. The constructor for the WordScrambler class takes an even-length array of String objects and initializes the instance variable scrambledWords.\n\npublic class WordScrambler\n{\nprivate String[] scrambledWords;\n\n    /** @param wordArr an array of String objects\n      * Precondition: wordArr.length is even\n      */\n    public WordScrambler (String[] wordArr)\n    {\n        scrambledWords = mixedWords(wordArr);\n    }\n\n    /** @param word1 a String of characters\n      * @param word2 a String of characters \n      * @return a String that contains the first \n      * half of word1 and the second half of word2\n      */\n    private String recombine (String word1, String word2) \n    { /* to be implemented in part (a) */ }\n\n    /** @param words an array of String objects\n     * Precondition: words.length is even \n     * @return an array of String objects created \n     * by recombining pairs of strings in array words \n     * Postcondition: the length of the returned \n     * array is words.length\n    */\n    private String[] mixedWords(String[] words) \n    { /* to be implemented in part (b) */ }\n\n    // There may be instance variables, constructors, \n    // and methods that are not shown.\n}\n\n(a) Write the WordScrambler method recombine. This method returns a String created from its two String parameters as follows.\n    - take the first half of word1 \n    - take the second half of word2 \n    - concatenate the two halves and return the new string.\nFor example, the following table shows some results of calling recombine. Note that if a word has an odd number of letters, the second half of the word contains the extra letter.\n\n    Word1\t\t  word2\t\trecombine (word1, word2)\n    \"Apple\"\t\t\"pear\"\t\t      \"apar\"\n    \"Pear\"\t\t\"apple\"\t\t      \"peple\"\n\nComplete method recombine below.\n\n/** @param word1 a String of characters\n  * @param word2 a String of characters \n  * @return a String that contains the first half \n  * of word1 and the second half of word2\n  */ \nprivate String recombine(String word1, String word2)\n\n(b) Write the WordScrambler method mixedWords. This method creates and returns a new array of String objects as follows. It takes the first pair of strings in words and combines them to produce a pair of strings to be included in the array returned by the method. If this pair of strings consists of w1 and w2, the method should include the result of calling recombine with w2 and w1 as arguments. The next two strings, if they exist, would form the next pair to be processed by this method. The method should continue until all the strings in words have been processed in this way and the new array has been filled. For example, if the array words contains the following elements:\n\n{ \"apple\", \"pear\", \"this\", \"cat\" }\n\nthen the call mixedWords(words) should return the following array.\n\n{\"apar\", \"peple\", \"that\", \"cis\"}\n\nIn writing mixedWords, you may call recombine. Assume that recombine works as specified, regardless of what you wrote in part (a). Complete method mixedWords below.\n\n/** @param words an array of String objects\n  * Precondition: words.length is even \n  * @return an array of String objects created by \n  * recombining pairs of strings in array words \n  * Postcondition: the length of the returned \n  * array is words.length\n  */ \nprivate String[] mixedWords(String[] words)\n\n",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["Compare Your Answer"], "picture_or_video_name": ""}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a)\npublic static int getPeakIndex(int[] array)\n{\n    for (int k = 1; k < array.length - 1; k++)\n    {\n        if ((array[k - 1] < array[k]) && (array[k] > array[k + 1]))\n            return k;\n    }\n    return -1;\n}\n\n(b)\npublic static boolean isMountain(int[] array) \n{\n    if (getPeakIndex(array) == -1)\n        return false; \n    if (!is Increasing(array, getPeakIndex(array))\n        return false; \n    if (!isDecreasing(array, getPeakIndex(array))\n        return false; \n    return true;\n}\n", "wrong_ans_explanation": "(a)\npublic static int getPeakIndex(int[] array)\n{\n    for (int k = 1; k < array.length - 1; k++)\n    {\n        if ((array[k - 1] < array[k]) && (array[k] > array[k + 1]))\n            return k;\n    }\n    return -1;\n}\n\n(b)\npublic static boolean isMountain(int[] array) \n{\n    if (getPeakIndex(array) == -1)\n        return false; \n    if (!is Increasing(array, getPeakIndex(array))\n        return false; \n    if (!isDecreasing(array, getPeakIndex(array))\n        return false; \n    return true;\n}\n",        "question": "An array of positive integer values has the mountain property if the elements are ordered such that successive values increase until a maximum value (the peak of the mountain) is reached and then the successive values decrease. The Mountain class declaration shown below contains methods that can be used to determine if an array has the mountain property. You will implement two methods in the Mountain class.\n\npublic class Mountain\n{\n    /** @param array an array of positive integer values\n      * @param stop the last index to check \n      * Precondition: 0 \u2264 stop \u2264 array.length \n      * @return true if for each j such that 0 \u2264 j < stop, \n      * array[j] < array[j + 1] ; \n      * false otherwise\n      */ \n    public static boolean isIncreasing(int[] array, int stop) \n    { /* implementation not shown */ }\n\n    /** @param array an array of positive integer values\n      * @param start the first index to check \n      * Precondition: 0 \u2264 start < array.length - 1 \n      * @return true if for each j such that \n      * start \u2264 j < array.length - 1, \n      * array[j] > array(j + 1]; \n      * false otherwise\n      */\n    public static boolean isDecreasing(int[] array, int start) \n    { /* implementation not shown */ }\n\n    /** @param array an array of positive integer values\n      * Precondition: array.length > 0 \n      * @return the index of the first peak (local maximum) \n      * in the array, if it exists, -1 otherwise\n      */ \n    public static int getPeakIndex(int[] array) \n    { /* to be implemented in part (a) */ }\n\n    /** @param array an array of positive integer values\n      * Precondition: array.length > 0 \n      * @return true if array contains values ordered \n      * as a mountain, false otherwise\n      */\n    public static boolean isMountain(int[] array) \n    { /* to be implemented in part (b) */ }\n\n    // There may be instance variables, constructors, \n    // and methods that are not shown.\n}\n\n(a) Write the Mountain method getPeakIndex. Method getPeakIndex returns the index of the first peak found in the parameter array, if one exists. A peak is defined as an element whose value is greater than the value of the element immediately before it and is also greater than the value immediately after it. Method getPeakIndex starts at the beginning of the array and returns the index of the first peak that is found or -1 if no peak is found. \n\nFor example, the following table illustrates the results of several calls to getPeakIndex.\n\n    arr\t\t\t\t\tgetPeakIndex(arr)\n\n[ 11, 22, 33, 22, 11 ]\t\t\t2\n[ 11, 22, 11, 22, 11 ]\t\t\t1\n[ 11, 22, 33, 55, 77 ]\t\t\t-1\n[99, 33, 55, 77, 120 ]\t\t\t-1\n[ 99, 33, 55, 77, 55 ]\t\t\t3\n[ 33, 22, 11 ]\t\t\t\t\t-1\n\nComplete method getPeakIndex below.\n\n/** @param array an array of positive integer values\n  * Precondition: array.length > 0 \n  * @return the index of the first peak (local maximum) \n  * in the array, if it exists, -1 otherwise\n  */ \npublic static int getPeakIndex(int[] array)\n\n(b) Write the Mountain method isMountain. Method isMountain returns true if the values in the parameter array are ordered as a mountain; otherwise, it returns false. The values in the array are ordered as a mountain if all three of the following conditions hold.\n\n    - There must be a peak. \n    - The array elements with an index smaller than the peaks index must appear in increasing order.\n    - The array elements with an Index larger than the peaks index must appear in decreasing order.\n \nFor example, the following table illustrates the results of several calls to isMountain.\n\narr \t\t\t\tisMountain (arr)\n\n[ 1, 2, 3, 2, 1 ] \t\ttrue (2)\n[ 1, 2, 1, 2, 1 ] \t\ttrue (1)\n[ 1, 2, 3, 1, 5 ]\t\tfalse (-1) \n[ 1, 4, 2, 1, 0 ] \t\tfalse (-1)\n[ 9, 3, 5, 7, 5 ]\t\ttrue (3)\n    [ 3, 2, 1 ]\t\t\tfalse (-1)\n\npublic static boolean isMountain(int[] array)\n",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["Compare Your Answer"], "picture_or_video_name": ""}, {"points": "15", "Answer": "0", "correct_ans_explanation": "(a)\npublic int getTotalBoxes()\n{\n    int j = 0;\n    for (int i = 0; i < orders.size(); i++)\n    {\n        j + = orders.get(i).getNumBoxes();\n    }\n    return j;\n}\n\n(b)\npublic int removeVariety(String cookieVar)\n{\n    int j = 0;\n    for (int i = 0; i < orders.size(); i++)\n    {\n        if (orders.get(i).getVariety().equals(cookieVar))\n        {\n            j += orders.get(i).getNumBoxes();\n            orders.remove(i--);\n        }\n    }\n    return j;\n}\n", "wrong_ans_explanation": "(a)\npublic int getTotalBoxes()\n{\n    int j = 0;\n    for (int i = 0; i < orders.size(); i++)\n    {\n        j + = orders.get(i).getNumBoxes();\n    }\n    return j;\n}\n\n(b)\npublic int removeVariety(String cookieVar)\n{\n    int j = 0;\n    for (int i = 0; i < orders.size(); i++)\n    {\n        if (orders.get(i).getVariety().equals(cookieVar))\n        {\n            j += orders.get(i).getNumBoxes();\n            orders.remove(i--);\n        }\n    }\n    return j;\n}\n",        "question": "An organization raises money by selling boxes of cookies. A cookie order specifies the variety of cookie and the number of boxes ordered. \n\nThe declaration of the CookieOrder class is shown below. \n\npublic class CookieOrder\n{\n    /** Constructs a new CookieOrder object. */ \n    public CookieOrder(String variety, int numBoxes) \n    { /* implementation not shown */ }\n\n    /** @return the variety of cookie being ordered */ \n    public String getVariety() \n    { /* implementation not shown */ }\n\n    /** @return the number of boxes being ordered */ \n    public int getNumBoxes() \n    { /* implementation not shown */ }\n\n    // There may be instance variables, constructors, \n    // and methods that are not shown.\n}\n\nThe MasterOrder class maintains a list of the cookies to be purchased. The declaration of the MasterOrder class is shown below.\n\npublic class MasterOrder\n{\n    /** The list of all cookie orders */ \n    private List<CookieOrder> orders;\n\n    /** Constructs a new MasterOrder object. */ \n    public MasterOrder() \n    { orders = new ArrayList<CookieOrder>(); }\n\n    /** Adds theOrder to the master order. \n     * @param the order the cookie order to add to the \n     * master order \n    */ \n    public void addOrder (CookieOrder theOrder) \n    { orders.add(theOrder); }\n\n    /** @return the sum of the number of boxes of all \n     * of the cookie orders\n    */\n\n    public int getTotalBoxes() \n    { /* to be implemented in part (a) */ }\n\n    /** Removes all cookie orders from the master order \n      * that have the same variety of \n      * cookie as cookieVar and returns the total \n      * number of boxes that were removed. \n      * @param cookieVar the variety of cookies to \n      * remove from the master order \n      * @return the total number of boxes of cookieVar \n      * in the cookie orders removed \n      */\n    public int removeVariety(String cookieVar) \n    { /* to be implemented in part (b) */ }\n\n    // There may be instance variables, constructors, \n    // and methods that are not shown.\n}\n\n(a) The getTotalBoxes method computes and returns the sum of the number of boxes of all cookie orders. If there are no cookie orders in the master order, the method returns 0. Complete method getTotalBoxes below.\n\n/** @return the sum of the number of boxes of all \n  * of the cookie orders\n */\npublic int getTotalBoxes()\n\n(b) The removeVariety method updates the master order by removing all of the cookie orders in which the variety of cookie matches the parameter cookieVar. The master order may contain zero or more cookie orders with the same variety as cookieVar. The method returns the total number of boxes removed from the master order. For example, consider the following code segment.\n\nMasterOrder goodies = new MasterOrder(); \ngoodies.addOrder(new CookieOrder(\"Chocolate Chip\", 1)); \ngoodies.addOrder(new CookieOrder(\"Shortbread\", 5)); \ngoodies.addOrder(new CookieOrder(\"Macaroon\", 2));\ngoodies.addOrder(new CookieOrder(\"Chocolate Chip\", 3));\n\nAlter the code segment has executed, the contents of the master order are as shown in the following table.\n\n\"Chocolate Chip\"\t: 1\n\"Shortbread\": 5 \n\"Macaroon\": 2\n\"Chocolate \nChip\": 3\n    \t\t        \nThe method call goodies.removeVariety(\"Chocolate Chip\") returns 4 because there were two Chocolate Chip cookie orders totaling 4 boxes. The master order is modified as shown below.\n\n\"Shortbread\": 5\t\t\n\"Macaroon\": 2\n\nThe method call goodies.removeVariety (\"Brownie\") returns 0 and does not change the master order.\n\n\nComplete method remove Variety below.\n/** Removes all cookie orders from the master order \n  * that have the same variety of \n  * cookie as cookieVar and returns the total number \n  * of boxes that were removed.\n  * @param cookieVar the variety of cookies to remove\n  * from the master order \n  * @return the total number of boxes of cookieVar \n  * in the cookie orders removed\n */\npublic int removeVariety (String cookieVar)\n",            "negative_points": "0", "duration_in_seconds": "1350",        "question_type": "5",    "options": ["Compare Your Answer"], "picture_or_video_name": ""}]}